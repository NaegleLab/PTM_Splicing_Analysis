import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from matplotlib.lines import Line2D
import matplotlib.lines as mlines
import matplotlib.pyplot as plt
from matplotlib_venn import venn2, venn2_circles
import seaborn as sns
import networkx as nx

import pandas as pd
import numpy as np
import re

import sys
sys.path.append('../../../PTM_POSE/')
from PTM_POSE import stat_utils, POSE_config

from lifelines import KaplanMeierFitter
import matplotlib.ticker as mtick


def expand_exon_self(exons, remove_duplicates = False):
    """
    Given exon self from splice seq, separate events with multiple exons into separate groups

    Parameters
    ----------
    exons: pd.selfFrame
        selfframe containing PSI exon self from splice seq
    remove_duplicates: bool
        whether to remove exons that appear across multiple events with conflicting direction (up and downregulated)

    Returns
    -------
    exons: pd.selfFrame
        Updated selfframe with exons separated into individual rows when multiple appearing in the same event
    """
    #split exons separately
    exons['Individual exon'] = exons['exons'].apply(lambda x: x.split(':'))
    exons = exons.explode('Individual exon')

    #if desired remove conflicting exons
    if remove_duplicates:
        exons = exons.drop_duplicates(subset = ['Symbol','Individual exon', 'ESRP1_MW'])
        exons = exons.drop_duplicates(subset = ['Symbol','Individual exon'], keep = False)
    return exons


class TCGA_Data:
    """
    Master class for analyzing TCGA data generated by TCGA_analysis.ipynb

    Parameters
    ----------
    figshare_dir: str
        directory where figshare data is stored
    pie_colors: list
        colors to use for pie charts
    bar_colors: list
        colors to use for bar charts
    tissue: str
        tissue to analyze
    effect_size: float
        minimum effect size (r) for significance
    alpha: float
        maximum p-value for significance
    min_psi_range: float
        minimum required variation in psi values across patients for significance
    cutoff: float
        cutoff for ESRP1 high and low groups
    
    """
    def __init__(self, figshare_dir, pie_colors = None, bar_colors = None, tissue = 'PRAD', effect_size = 0.3, alpha = 0.01, min_psi_range = 0.25, cutoff = 1):
        self.cutoff = cutoff
        self.tissue = tissue

        analysis_dir = f'{figshare_dir}/Analysis_For_Paper/'
        database_dir = f'{figshare_dir}/External_Data/'

        #load ESRP1 expression self
        mRNA = pd.read_csv(database_dir + f"TCGA/PRAD/cBio/PRAD_mRNA expression z-scores relative to all samples (log RNA Seq V2 RSEM).txt", sep = '\t') # Z-score of ESPR1 


        #load PRAD self
        self.PSI_events = pd.read_csv(analysis_dir + f"/TCGA/PSI_events_{tissue}.csv") # PSI self
        self.PSI_exons = pd.read_csv(analysis_dir + f"/TCGA/PSI_exons_{tissue}.csv")
        self.PSI_ptms = pd.read_csv(analysis_dir + f"/TCGA/PSI_ptms_{tissue}.csv", dtype={"PTM Position in Canonical Isoform": str})
        self.PSI_ptms = self.PSI_ptms[~self.PSI_ptms['UniProtKB Accession'].str.contains(';')]
        self.annotated_ptms = pd.read_csv(analysis_dir + f'/TCGA/PRAD_annotated_ptms.csv', dtype={"PTM Position in Canonical Isoform": str, 'PSP:ON_OTHER_INTERACT':str})
        self.flanking_sequences = pd.read_csv(analysis_dir + f'/TCGA/changed_flank_sequences_PRAD.csv')
        self.flanking_sequences['Source of PTM'] = self.flanking_sequences['Source of PTM'].apply(lambda x: x.split(';')[0])
    
        #extract only changed flanking sequences
        self.flanking_sequences = self.flanking_sequences[~self.flanking_sequences['Matched']]
        self.flanking_sequences = self.flanking_sequences.dropna(subset = ['Inclusion Flanking Sequence', 'Exclusion Flanking Sequence'])
        self.flanking_sequences = self.flanking_sequences[(~self.flanking_sequences['Inclusion Flanking Sequence'].str.contains('X')) & (~self.flanking_sequences['Exclusion Flanking Sequence'].str.contains('X'))]
        self.flanking_sequences = self.flanking_sequences[(self.flanking_sequences['Inclusion Flanking Sequence'].apply(len) == 11) & (self.flanking_sequences['Exclusion Flanking Sequence'].apply(len) == 11)]

        #convert PTM labels to make sure its consistent
        self.PSI_ptms['PTM'] = self.PSI_ptms.apply(lambda x: x['UniProtKB Accession'] + '_' + x['Residue']+ str(int(float(x['PTM Position in Canonical Isoform']))) if x['PTM Position in Canonical Isoform'] == x['PTM Position in Canonical Isoform'] else x['Source of PTM'].split(';')[0], axis = 1)
        self.annotated_ptms['PTM'] = self.annotated_ptms.apply(lambda x: x['UniProtKB Accession'] + '_' + x['Residue']+ str(int(float(x['PTM Position in Canonical Isoform']))) if x['PTM Position in Canonical Isoform'] == x['PTM Position in Canonical Isoform'] else x['Source of PTM'].split(';')[0], axis = 1)
        self.flanking_sequences['PTM'] = self.flanking_sequences['Source of PTM'].apply(lambda x: x.split(';')[0])
        self.flanking_sequences['PTM'] = self.flanking_sequences['PTM'].apply(lambda x: x.split('-')[0]+'_'+x.split('_')[1])

        mRNA = mRNA.dropna(subset = 'ESRP1')
        #remove patients with no measured ESRP1 mRNA from splice self, or vice versa
        mRNA['Edited Patient ID'] = mRNA['SAMPLE_ID'].apply(lambda x: '_'.join(x.split('-')[0:3])).to_list()
        patients_to_drop = [col for col in self.PSI_events.columns if col not in mRNA['Edited Patient ID'].values and 'TCGA' in col]
        self.PSI_events = self.PSI_events.drop(patients_to_drop, axis = 1)
        self.PSI_exons = self.PSI_exons.drop(patients_to_drop, axis = 1)
        self.PSI_ptms = self.PSI_ptms.drop(patients_to_drop, axis = 1)
        mRNA.set_index('Edited Patient ID', inplace = True)

        #remove patients with no measured splice self from ESRP1 self
        patients_to_drop = [col for col in mRNA.index if col not in self.PSI_events.columns]
        mRNA = mRNA[~mRNA.index.isin(patients_to_drop)].copy()
        self.mRNA = mRNA

        
        #grab esrp rsem
        rsem = pd.read_csv(database_dir + f'TCGA/PRAD/cBio/PRAD_mRNA Expression, RSEM (Batch normalized from Illumina HiSeq_RNASeqV2).txt', sep = '\t')
        rsem['Edited Patient ID'] = rsem['SAMPLE_ID'].apply(lambda x: '_'.join(x.split('-')[0:3])).to_list()
        rsem = rsem.set_index('Edited Patient ID')
        self.esrp1_rsem = rsem['ESRP1']

        #self.mapped_ptms = pd.read_csv('../../../TCGA/self/splicegraph_ptms.csv', dtype = {'Chromosome': str})
        #self.mapped_ptms['PTM'] = self.mapped_ptms.apply(lambda row: row['UniProtKB Accession'] + '_' + row['Residue']+ str(int(row['PTM Position in Canonical Isoform'])) if row['PTM Position in Canonical Isoform'] == row['PTM Position in Canonical Isoform'] else row['Source of PTM'].split(';')[0], axis = 1)
        self.splicegraph = pd.read_csv(analysis_dir + "/TCGA/splicegraph_exons.csv") #SpliceSeq self

        #store directories
        self.analysis_dir = analysis_dir
        self.database_dir = database_dir
        self.figshare_dir = figshare_dir

        #get esrp1 higha nd low groups
        self.get_ESRP1_groups()

        self.extract_significant_exons(min_psi_range = min_psi_range, alpha = alpha, effect_size = effect_size)
        self.extract_significant_ptms(min_psi_range = min_psi_range, alpha = alpha, effect_size = effect_size)

        #set colors for plots
        self.palette = sns.color_palette('colorblind')
        self.pie_colors = [self.palette[2],self.palette[1],self.palette[0]] if pie_colors is None else pie_colors
        self.bar_colors = ['bisque','darkorange',self.palette[2]] if bar_colors is None else bar_colors

    def get_ESRP1_groups(self):
        ## Pull low and high 
        mRNA = self.mRNA.dropna(subset = 'ESRP1').copy()
        ESPR_low = mRNA[mRNA["ESRP1"] < -1*self.cutoff]
        ESRP1_low_id = ESPR_low["SAMPLE_ID"].str.split("-").apply(lambda x: x[0:3]).apply(lambda x: '_'.join(x)).to_list()
        ESPR_high = mRNA[mRNA["ESRP1"] > self.cutoff]
        ESRP1_high_id = ESPR_high["SAMPLE_ID"].str.split("-").apply(lambda x: x[0:3]).apply(lambda x: '_'.join(x)).to_list()
        print(f'Number of ESRP1 low patients: {len(ESRP1_low_id)} ({round(len(ESRP1_low_id)/self.mRNA["SAMPLE_ID"].nunique()*100, 2)}%))')
        print(f'Number of ESRP1 high patients: {len(ESRP1_high_id)} ({round(len(ESRP1_high_id)/self.mRNA["SAMPLE_ID"].nunique()*100, 2)}%)')

        self.ESRP1_low = ESRP1_low_id
        self.ESRP1_high = ESRP1_high_id

    def extract_significant_exons(self, alpha = 0.05, effect_size = 0.25, min_psi_range = 0.25, by = "MW", duplicate_handling = 'conflicting_sig'):
        """
        Given the PSI_exons self (generate if not yet created), identify the PTMs that are differentially spliced between ESRP1 high and low groups

        Parameters
        ----------
        alpha: float
            maximum p-value for significance
        effect_size: float
            minimum effect size (r) for significance
        min_psi_range: float
            minimum required variation in psi values across patients for significance
        by: str
            method to use for significance testing. Either "MW" (mann whitney U test) or "Corr" (spearman rank correlation)
        duplicate_handling: str
            how to handle PTMs involved in multiple splice events. Options include:
                1. 'strict': remove any duplicate entries of PTMs
                2. 'loose': don't remove any duplicates
                3. 'conflicting_sig': remove any entries that appear as significant in both high and low groups
                4. 'conflicting_any': remove any entries that appear with multiple classifications (insignificant, high, or low). This is different from conflicting_sig in that it will also remove any PTM that is significant for one event but not another.
        """
        #identify events that are significant
        sig_exons = self.PSI_exons.copy()
        sig_exons['Significant Event'] = True
        sig_exons.loc[(sig_exons[f'p-adj_{by}'] >= alpha), 'Significant Event'] = False
        sig_exons.loc[(sig_exons[f'Effect Size_{by}'] <= effect_size), 'Significant Event'] = False
        sig_exons.loc[(sig_exons['psi_range'] <= min_psi_range), 'Significant Event'] = False

        #remove duplicate PTM entries according to duplicate_handling
        if duplicate_handling == 'strict': #remove any duplicate entries of PTMs
            sig_exons = sig_exons[sig_exons['Significant Event']]
            sig_exons = sig_exons.drop_duplicates(subset = ['symbol', 'Individual exon'])
        elif duplicate_handling == 'loose': #only remove insignificant events, keep duplicate PTM entries
            sig_exons = sig_exons[sig_exons['Significant Event']]
        elif duplicate_handling == 'conflicting_sig':   #remove events that suggest both up and down regulated
            sig_exons = sig_exons[sig_exons['Significant Event']]
            sig_exons = sig_exons.drop_duplicates(subset = ['symbol','Individual exon', f'ESRP1_{by}'])
            sig_exons = sig_exons.drop_duplicates(subset = ['symbol', 'Individual exon'], keep = False)
        elif duplicate_handling == 'conflicting_any':   #remove events that suggest multiple of up, down, or unregulated
            sig_exons = sig_exons.drop_duplicates(subset = ['symbol','Individual exon', f'ESRP1_{by}', 'Significant Event'])
            sig_exons = sig_exons.drop_duplicates(subset = ['symbol', 'Individual exon'], keep = False)
            sig_exons = sig_exons[sig_exons['Significant Event']]

        #record significant ptms and parameters used to get them
        self.significance_by = by
        self.sig_exons = sig_exons
        self.alpha = alpha
        self.effect_size = effect_size
        self.min_psi_range = min_psi_range
        self.duplicate_handling = duplicate_handling

    def extract_significant_ptms(self, alpha = 0.05, effect_size = 0.25, min_psi_range = 0.25, by = "MW", duplicate_handling = 'conflicting_sig'):
        """
        Given the PSI_ptms self (generate if not yet created), identify the PTMs that are differentially spliced between ESRP1 high and low groups

        Parameters
        ----------
        alpha: float
            maximum p-value for significance
        effect_size: float
            minimum effect size (r) for significance
        min_psi_range: float
            minimum required variation in psi values across patients for significance
        by: str
            method to use for significance testing. Either "MW" (mann whitney U test) or "Corr" (spearman rank correlation)
        duplicate_handling: str
            how to handle PTMs involved in multiple splice events. Options include:
                1. 'strict': remove any duplicate entries of PTMs
                2. 'loose': don't remove any duplicates
                3. 'conflicting_sig': remove any entries that appear as significant in both high and low groups
                4. 'conflicting_any': remove any entries that appear with multiple classifications (insignificant, high, or low). This is different from conflicting_sig in that it will also remove any PTM that is significant for one event but not another.
        """
        #identify events that are significant
        sig_ptms = self.PSI_ptms.copy()
        sig_ptms['Significant Event'] = True
        sig_ptms.loc[(sig_ptms[f'p-adj_{by}'] >= alpha), 'Significant Event'] = False
        sig_ptms.loc[(sig_ptms[f'Effect Size_{by}'] <= effect_size), 'Significant Event'] = False
        sig_ptms.loc[(sig_ptms['psi_range'] <= min_psi_range), 'Significant Event'] = False

        #remove duplicate PTM entries according to duplicate_handling
        if duplicate_handling == 'strict': #remove any duplicate entries of PTMs
            sig_ptms = sig_ptms[sig_ptms['Significant Event']]
            sig_ptms = sig_ptms.drop_duplicates(subset = 'PTM')
        elif duplicate_handling == 'loose': #only remove insignificant events, keep duplicate PTM entries
            sig_ptms = sig_ptms[sig_ptms['Significant Event']]
        elif duplicate_handling == 'conflicting_sig':   #remove events that suggest both up and down regulated
            sig_ptms = sig_ptms[sig_ptms['Significant Event']]
            sig_ptms = sig_ptms.drop_duplicates(subset = ['PTM', f'ESRP1_{by}'])
            sig_ptms = sig_ptms.drop_duplicates(subset = 'PTM', keep = False)
        elif duplicate_handling == 'conflicting_any':   #remove events that suggest multiple of up, down, or unregulated
            sig_ptms = sig_ptms.drop_duplicates(subset = ['PTM', f'ESRP1_{by}', 'Significant Event'])
            sig_ptms = sig_ptms.drop_duplicates(subset = 'PTM', keep = False)
            sig_ptms = sig_ptms[sig_ptms['Significant Event']]

        #record significant ptms and parameters used to get them
        self.significance_by = by
        self.sig_ptms = sig_ptms
        self.alpha = alpha
        self.effect_size = effect_size
        self.min_psi_range = min_psi_range
        self.duplicate_handling = duplicate_handling

    def extract_ptms_related_to_term(self, term = None):
        """
        given a Gene-level term of interest, extract the genes associated with the term and the subsequent ptms associated with those genes

        Parameters
        ----------
        ptm_results: pd.selfFrame
            selfFrame containing PTM-specific results from EnrichR analysis
        self: Figure4_new
            Figure4_new object containing PTM self
        term: str
            term of interest to extract PTMs from, must match column in ptm_results. If none will return all significant ptms
        """
        relevant_ptm_annotations = self.annotated_ptms[self.annotated_ptms['Source of PTM'].isin(self.sig_ptms['Source of PTM'])].copy()
        relevant_ptm_psi = self.sig_ptms.copy()
        relevant_flanks = self.annotated_ptms[self.annotated_ptms['Source of PTM'].isin(self.flanking_sequences['Source of PTM'])].copy()

        if term is not None:
            if not hasattr(self, 'enrichr'):
                self.process_enrichr()

            relevant_genes = self.enrichr.loc[self.enrichr['Term'] == term, 'Genes_ptm'].str.split(';').values[0]
            relevant_ptm_annotations = relevant_ptm_annotations[(relevant_ptm_annotations['Gene'].isin(relevant_genes))].copy()
            relevant_flanks = relevant_flanks[relevant_flanks['Gene'].isin(relevant_genes)].copy()
            relevant_ptm_psi = self.sig_ptms[self.sig_ptms['Gene'].isin(relevant_genes)]


        relevant_ptm_annotations = pd.concat([relevant_ptm_annotations, relevant_flanks])
        relevant_ptm_annotations['PTM'] =  relevant_ptm_annotations.apply(lambda x: x['UniProtKB Accession'] + '_' + x['Residue']+ str(int(float(x['PTM Position in Canonical Isoform']))) if x['PTM Position in Canonical Isoform'] == x['PTM Position in Canonical Isoform'] else x['Source of PTM'].split(';')[0], axis = 1)
        return relevant_ptm_annotations, relevant_ptm_psi

    def breakdown_events(self):

        self.PSI_exons['Region ID'] = self.PSI_exons['symbol'] + '_' + self.PSI_exons['Individual exon'].astype(str)
        self.sig_exons['Region ID'] = self.sig_exons['symbol'] + '_' + self.sig_exons['Individual exon'].astype(str)
        self.sig_ptms['Region ID'] = self.sig_ptms['Gene'] + '_' + self.sig_ptms['Individual exon'].astype(str)


        prad_splicegraph= self.splicegraph[self.splicegraph['Symbol'].isin(self.PSI_events['symbol'].unique())]

        #gene information
        total_genes = prad_splicegraph['Symbol'].unique()
        total_genes_with_controlled_exons = self.sig_exons['symbol'].unique()
        total_genes_with_controlled_ptms = self.sig_ptms['Gene'].unique()
        total_genes_with_altered_ptms_only = set(self.flanking_sequences.loc[~self.flanking_sequences['Matched'], 'Gene'].unique()).difference(total_genes_with_controlled_ptms)


        #exon information
        total_exons = prad_splicegraph['Exon Label'].unique()
        total_controlled_exons = self.sig_exons['Region ID'].unique()
        total_controlled_exons_with_ptms = self.sig_ptms['Region ID'].unique()
        total_controlled_exons_with_altered_flanks_only = set(self.flanking_sequences.loc[~self.flanking_sequences['Matched'], 'Region ID'].unique()).difference(total_controlled_exons_with_ptms)

        #PTM information
        total_ptms = self.annotated_ptms['PTM'].unique()
        total_controlled_ptms = self.sig_ptms['PTM'].unique()
        total_ptms_with_altered_flanks = set(self.flanking_sequences.loc[~self.flanking_sequences['Matched'], 'PTM'].unique()).difference(total_controlled_ptms)

        #save self
        self.total_genes = total_genes
        self.total_genes_with_controlled_exons = total_genes_with_controlled_exons
        self.total_genes_with_controlled_ptms = total_genes_with_controlled_ptms
        self.total_genes_with_altered_ptms_only = total_genes_with_altered_ptms_only

        self.total_exons = total_exons
        self.total_controlled_exons = total_controlled_exons
        self.total_controlled_exons_with_ptms = total_controlled_exons_with_ptms
        self.total_controlled_exons_with_altered_flanks_only = total_controlled_exons_with_altered_flanks_only

        self.total_ptms = total_ptms
        self.total_controlled_ptms = total_controlled_ptms
        self.total_ptms_with_altered_flanks = total_ptms_with_altered_flanks

    def load_patient_data(self):
        self.oncoprint = pd.read_csv(self.database_dir + f'TCGA/PATIENT_DATA_oncoprint.tsv', sep = '\t')
        self.getSurvival()
        self.getStatus()
    
    def getSurvival(self):
        survival = self.oncoprint[self.oncoprint['track_name'] == 'Progress Free Survival (Months)']
        survival = survival.drop(columns = ['track_name','track_type'], axis = 1)
        survival.index = ['Survival']
        survival = survival.squeeze()
        survival = survival.astype(float)
        self.survival = survival
    
    def getStatus(self):
        #get status of measurement (censored or progression/death
        # #progression free status
        status = self.oncoprint[self.oncoprint['track_name'] == 'Progression Free Status']
        status = status.drop(columns = ['track_name','track_type'], axis = 1)
        status.index = ['Status']
        status = status.squeeze()

        #convert status to boolean
        status = status.apply(lambda x: True if x == '1:PROGRESSION' else False)
        self.status = status

    def print_breakdown(self):
        if not hasattr(self, 'total_genes'):
            self.breakdown_events()
        
        print(f'Within PRAD, {len(self.total_genes)} genes have {len(self.total_exons)} exons and {len(self.total_genes_with_controlled_exons)} have significant exon inclusion changes ({round(len(self.total_controlled_exons)/len(self.total_exons) *100,2)}%).')
        print(f'Among these exons, there are {len(self.total_ptms)} PTMs and {len(self.total_controlled_ptms)} have significant changes ({round(len(self.total_controlled_ptms)/len(self.total_ptms) * 100, 2)}%). {len(self.total_genes_with_controlled_ptms)} genes have significant PTM changes.')
        print(f'In addition, {len(self.total_genes_with_altered_ptms_only)} genes have altered PTMs without significant PTM inclusion changes. This includes a total of {len(self.total_controlled_exons_with_altered_flanks_only)} exons and {len(self.total_ptms_with_altered_flanks)} PTMs.')

    def print_exon_containing_ptm_info(self):
        if not hasattr(self, 'total_genes'):
            self.breakdown_events()

        print('Number of spliced exons with PTMs:', len(self.total_controlled_exons_with_ptms))
        print('Fraction of spliced exons with PTMs:', len(self.total_controlled_exons_with_ptms)/(len(self.total_controlled_exons) - len(self.total_controlled_exons_with_ptms)))

    def sig_heatmap(self, ax = None):
        """
        Plot patient-specific percent spliced in (PSI) for PTMs differentially spliced due to ESRP1 expression. Only includes patients in either ESRP1-low or ESRP1-high groups

        Parameters
        ----------
        zscore: bool
            whether to zscore the self (currently always does this regard)
        """
        heatmap_self = self.sig_ptms.sort_values(by = 'deltaPSI_MW').copy()

        self_cols = [col for col in heatmap_self.columns if 'TCGA' in col]
        heatmap_self[self_cols] = heatmap_self[self_cols].apply(lambda x: (x-x.mean())/x.std(), axis = 1)
        cmap = 'coolwarm'
        vmin = -3
        vmax = 3
        cbar_label = 'Percent Spliced In (PSI), Z-Scored'


        heatmap_self.index = heatmap_self['PTM']
        heatmap_self = heatmap_self[self.ESRP1_low + self.ESRP1_high]

        esrp1 = self.mRNA['ESRP1']
        esrp1 = esrp1.loc[heatmap_self.columns].sort_values()
        heatmap_self = heatmap_self[esrp1.index]


        fig, axes = plt.subplots(figsize = (3,3),nrows = 3, ncols = 4, width_ratios = [0.15,1,0.05,0.05],height_ratios = [0.1,0.15,1])
        fig.subplots_adjust(hspace = 0, wspace = 0)

        sns.heatmap(heatmap_self, xticklabels=False, yticklabels = False, cmap = cmap, center = 0, vmin = vmin, vmax = vmax, cbar_kws = {'label':cbar_label}, ax = axes[2,1], cbar_ax = axes[2,3])
        #change colorbar fontsize
        axes[2,3].set_ylabel(cbar_label, fontsize = 8)
        axes[2,3].tick_params(labelsize = 7)

        axes[2,1].set_ylabel('')
        axes[0,0].axis('off')
        axes[0,3].axis('off')
        axes[0,2].axis('off')
        axes[1,2].axis('off')
        axes[2,2].axis('off')
        axes[1,3].axis('off')
        axes[1,0].axis('off')




        #add context bar indicating esrp1-low patients
        num_low_patients = len(self.ESRP1_low)
        num_high_patients = len(self.ESRP1_high)
        axes[1,1].barh(0, num_low_patients, color = 'white', edgecolor = 'black', linewidth = 1)
        axes[1,1].barh(0, num_high_patients, left = num_low_patients, color = 'white', edgecolor = 'black', linewidth = 1)
        axes[1,1].axis('off')
        axes[1,1].set_xlim(axes[2,1].get_xlim())
        axes[1,1].text(num_low_patients/2, 0, f'{num_low_patients} ESRP1-Low\nPatients', ha = 'center', va = 'center', fontsize = 6)
        axes[1,1].text(num_low_patients + num_high_patients/2, 0, f'{num_high_patients} ESRP1-High\nPatients', ha = 'center', va = 'center', fontsize = 6)

        #add mRNA RSEM
        esrp1_rsem = self.esrp1_rsem[[i for i in heatmap_self.columns if i in self.esrp1_rsem.index]].copy()
        #axes[0,1].bar(esrp1_rsem.index, esrp1_rsem.values)
        axes[0,1].set_xticks([])
        axes[0,1].bar(list(range(num_low_patients)),esrp1_rsem[esrp1_rsem.index.isin(self.ESRP1_low)].values, color = 'lightgrey',edgecolor = 'black', linewidth = 0.1, width = 1, align = 'edge')
        axes[0,1].bar(list(range(num_low_patients, num_high_patients+num_low_patients)),esrp1_rsem[esrp1_rsem.index.isin(self.ESRP1_high)].values, color = 'gray',edgecolor = 'black', linewidth = 0.1, width = 1, align = 'edge')
        axes[0,1].set_xlim([0,129])
        axes[0,1].yaxis.tick_right()
        axes[0,1].yaxis.set_label_position('right')
        axes[0,1].set_ylabel('ESRP1\nRSEM', rotation = 0, va = 'center', ha = 'left', fontsize = 8)
        axes[0,1].tick_params(labelsize = 7)
        axes[0,1].set_yticks([0,8000])



        #add context bar indicating PTM groups
        inclusion_groups = self.sig_ptms.groupby('ESRP1_MW').size()

        axes[2,0].bar(0, inclusion_groups['Low'], bottom = 0.5, color = 'white', edgecolor = 'black', linewidth = 1)
        axes[2,0].bar(0, inclusion_groups['High']-0.01, bottom = inclusion_groups['Low'], color = 'white', edgecolor = 'black', linewidth = 1)
        axes[2,0].axis('off')
        axes[2,0].set_ylim(axes[2,1].get_ylim())
        axes[2,0].text(0, inclusion_groups['Low']/2, f"{inclusion_groups['Low']} Excluded\nPTMs", ha = 'center', va = 'center', rotation = 90, fontsize = 6)
        axes[2,0].text(0, inclusion_groups['Low'] + inclusion_groups['High']/2 , f"{inclusion_groups['High']} Included\nPTMs", rotation = 90, ha = 'center', va = 'center', fontsize = 6)


    def plot_summary_pie(self, type = 'half', colors = None, ax = None):
        if not hasattr(self, 'total_genes'):
            self.breakdown_events()

        if ax is None:
            fig, ax = plt.subplots(figsize = (2.5,2.5))

        if type == 'half':
            self.plot_summary_half_pie(ax, colors = colors)
        else:
            print('not written yet')

    def plot_summary_half_pie(self, ax, colors = None):
        """
        Plot a summary pie chart indicating the percentage of genes, exons, and PTMs that are impacted by splicing, and in what way

        Parameters
        ----------
        ax: matplotlib.Axes
            axis to plot on
        """
        # gene groups
        sizes = [len(self.total_genes_with_altered_ptms_only), len(self.total_genes_with_controlled_ptms), len(self.total_genes_with_controlled_exons) - len(self.total_genes_with_controlled_ptms) - len(self.total_genes_with_altered_ptms_only)]

        # set colors
        if colors is None:
            palette = sns.color_palette('colorblind')
            palette = [palette[0], palette[1], palette[2], 'white']
        else:
            palette = [colors[0],colors[1],colors[2],'white']

        #plot pie (wedge chart)
        half_pie_plot(sizes, ax, label_percents = True, total_for_percent = len(self.total_genes), radius = 2, percent_offset = 0.9, wedge_width = 0.5, palette = palette, percent_size = 6)
        

        #exon groups and pie chart (wedge chart)
        sizes = [len(self.total_controlled_exons_with_altered_flanks_only), len(self.total_controlled_exons_with_ptms), len(self.total_controlled_exons) - len(self.total_controlled_exons_with_ptms) - len(self.total_controlled_exons_with_altered_flanks_only)]
        half_pie_plot(sizes, ax, label_percents = True, total_for_percent = len(self.total_exons), radius = 1.4, percent_offset = 0.8, wedge_width = 0.5, palette = palette, percent_size = 6)

        #ptm groups and pie chart (full half circle)
        sizes = [len(self.total_ptms_with_altered_flanks), len(self.total_controlled_ptms)]
        sizes.append(sum(sizes))  # 50% blank
        radius = 0.8
        ax.pie(sizes, colors = [palette[0], palette[1],palette[3]], autopct='', radius = radius, textprops={'fontsize': 7})
        # Calculate percentages and add labels
        total = sum(sizes)
        circumference = 2 * np.pi
        cumulative_sizes = np.cumsum(sizes)
        for i, size in enumerate(sizes):
            if i !=2:
                theta = 2 * np.pi * ((cumulative_sizes[i] - size/2) / total)  # angle of the pie slice
                rotation = np.degrees(theta) - 90
                if i == 0:
                    rotation = 0
                    r = radius*0.7
                else:
                    r = radius*0.5
                pct = (size/len(self.total_ptms))*100
                x = r * np.cos(theta)
                y = r * np.sin(theta)
                rotation = np.degrees(theta) - 90
                if i == 0:
                    rotation = 0

                ax.text(x, y,  f'{pct:.1f}%', rotation = rotation, ha='center', va = 'center', fontsize = 6)
        
        #create legend
        ax.legend(['Spliced (Altered Flank)', 'Spliced (Inclusion Change)', 'Spliced (PTMs Unchanged)'], loc = 'lower center', bbox_to_anchor = (0.5, 0.2),fontsize = 7)

        ax.text(0, 1.9, f'Genes', ha = 'center', va = 'center', fontsize = 8, weight = 'bold')
        ax.text(0, 1.35, 'Exons', ha = 'center', va = 'center', fontsize = 8, weight = 'bold')
        ax.text(0, 0.7, 'PTMs', ha = 'center', va = 'center', fontsize = 8, weight = 'bold')
        ax.set_xlim([-2,2])
        ax.set_ylim([-2,2])

    def process_enrichr(self):
        if not hasattr(self, 'total_genes'):
            self.breakdown_events()
        #grab genes with impacted ptms
        foreground_ptms = list(self.total_genes_with_controlled_ptms) + list(self.total_genes_with_altered_ptms_only)
        #grab genes with and without ptms impacted by splice events
        genes_with_spliced_ptms = list(self.total_genes_with_controlled_ptms)
        genes_with_altered_ptms = list(self.total_genes_with_altered_ptms_only)
        genes_with_no_spliced_ptms = set(self.total_genes_with_controlled_exons).difference(genes_with_spliced_ptms + genes_with_altered_ptms)

        #load enrichr results and separate based on whether only ptm-impacted genes were considered or not
        enrichr_results = pd.read_csv(self.analysis_dir + f'/TCGA/EnrichR_results.csv')
        ptm_results = enrichr_results[enrichr_results['Test Type'] == 'PTMs Impacted'].copy()
        all_results = enrichr_results[enrichr_results['Test Type'] == 'All']

        #grab number info for genes with and without ptms
        all_results = all_results[all_results['Term'].isin(ptm_results['Term'].values)].copy()
        all_results['Number of No PTM Genes'] = all_results['Genes'].apply(lambda genes: sum([1 for g in genes.split(';') if g in genes_with_no_spliced_ptms]))
        all_results['Number of With Spliced PTM Genes'] = all_results['Genes'].apply(lambda genes: sum([1 for g in genes.split(';') if g in genes_with_spliced_ptms]))
        all_results['Number of With Altered PTM Genes'] = all_results['Genes'].apply(lambda genes: sum([1 for g in genes.split(';') if g in genes_with_altered_ptms]))
        all_results['Total Genes'] = all_results['Genes'].apply(lambda genes: len(genes.split(';')))

        #add all_results gene info to ptm results
        ptm_results = ptm_results.merge(all_results[['Term', 'Number of No PTM Genes', 'Number of With Spliced PTM Genes', 'Number of With Altered PTM Genes', 'Total Genes', 'Genes']], on = 'Term', how = 'left', suffixes=('_ptm', '_gene'))
        
        ptm_results = ptm_results.sort_values(by = 'Combined Score', ascending = True)
        ptm_results['Fraction With PTMs']= (ptm_results['Number of With Spliced PTM Genes']+ptm_results['Number of With Altered PTM Genes'])/ptm_results['Total Genes']
        ptm_results = ptm_results.sort_values('Fraction With PTMs', ascending = False)
        
        self.enrichr = ptm_results



    def plot_annotations(self, term_to_plot = 'EXONT:Name', colors = None, collapse_on_similar = False, top_terms = 5, gene_term = None, legend = True, leg_loc = (-2.5,-0.6), ax = None):
        if not hasattr(self, 'total_genes'):
            self.breakdown_events()

        if not hasattr(self, 'enrichr'):
            self.process_enrichr()

        relevant_annotated_ptms = self.extract_ptms_related_to_term(gene_term)[0]
        
        if not hasattr(self, 'high_ptm_list'):
            high_ptms = self.sig_ptms.loc[self.sig_ptms['ESRP1_MW'] == 'High']
            self.high_ptm_list = high_ptms.apply(lambda x: x['UniProtKB Accession'] + '_' + x['Residue']+ str(int(float(x['PTM Position in Canonical Isoform']))) if x['PTM Position in Canonical Isoform'] == x['PTM Position in Canonical Isoform'] else x['Source of PTM'].split(';')[0], axis = 1).unique()
            low_ptms = self.sig_ptms.loc[self.sig_ptms['ESRP1_MW'] == 'Low']
            self.low_ptm_list = low_ptms.apply(lambda x: x['UniProtKB Accession'] + '_' + x['Residue']+ str(int(float(x['PTM Position in Canonical Isoform']))) if x['PTM Position in Canonical Isoform'] == x['PTM Position in Canonical Isoform'] else x['Source of PTM'].split(';')[0], axis = 1).unique()
            relevant_flanks = self.annotated_ptms[self.annotated_ptms['Source of PTM'].isin(self.flanking_sequences['Source of PTM'])].copy()
            flank_ptm_list =  relevant_flanks.apply(lambda x: x['UniProtKB Accession'] + '_' + x['Residue']+ str(int(float(x['PTM Position in Canonical Isoform']))) if x['PTM Position in Canonical Isoform'] == x['PTM Position in Canonical Isoform'] else x['Source of PTM'].split(';')[0], axis = 1)
            self.flank_ptm_list = list(set(flank_ptm_list).difference(self.high_ptm_list).difference(self.low_ptm_list))

        if ax is None:
            fig, ax = plt.subplots(figsize = (2,3))

        if colors is None:
            colors = ['lightgrey', 'gray', 'white']
        plot_ptms_with_term(relevant_annotated_ptms, term_to_plot, self.high_ptm_list, self.low_ptm_list, self.flank_ptm_list, colors = colors, top_terms = top_terms, collapse_on_similar = collapse_on_similar, ax = ax)
        
        label_dict = {'EXONT:Name':'Exon Ontology Term', 'PSP:ON_PROCESS':'Biological Process (PSP)', 'PSP:ON_FUNCTION':'Molecular Function (PSP)', 'Combined:Kinase':'Kinase'}
        ax.text(-1*ax.get_xlim()[1]/10, top_terms-0.2, label_dict[term_to_plot], weight = 'bold', ha = 'right', fontsize = 8)
        xlabel_dict = {'EXONT:Name':'Number of PTMs\nFound in Exons', 'PSP:ON_PROCESS':'Number of PTMs\nassociated with Biological\nProcess', 'PSP:ON_FUNCTION':'Number of PTMs\nassociated with Molecular\nFunction' ,'Combined:Kinase':'Number of\nSubstrates'}
        ax.set_xlabel(xlabel_dict[term_to_plot], fontsize = 8)
        
        #make a custom legend
        if legend:
            import matplotlib.patches as mpatches
            handles = [mpatches.Patch(facecolor = colors[0], edgecolor = 'black', label = 'Excluded'), mpatches.Patch(facecolor = colors[1], edgecolor = 'black', label = 'Included'),mpatches.Patch(facecolor = colors[2], edgecolor = 'black', label = 'Altered Flank')]
            ax.legend(handles = handles, ncol = 1, loc = 'lower left', bbox_to_anchor = leg_loc, fontsize = 7, title = 'Type of Impact', title_fontsize = 8)
        ax.tick_params(labelsize = 7)

    def process_kinase_activities(self):
        kstar_st = pd.read_csv(self.analysis_dir + '/TCGA/Kinase_Enrichment/KSTAR_Median_Enrichments_ST.csv', index_col = 0)
        kstar_y = pd.read_csv(self.analysis_dir + '/TCGA/Kinase_Enrichment/KSTAR_Median_Enrichments_Y.csv', index_col = 0)
        self.kstar_results = pd.concat([kstar_y, kstar_st], axis = 0)

class Figure4:
    def __init__(self, TCGA_data, palette = None, pie_colors = None, bar_colors = None):
        self.palette = sns.color_palette('colorblind') if palette is None else palette
        self.pie_colors = TCGA_data.pie_colors if pie_colors is None else pie_colors
        self.bar_colors = TCGA_data.bar_colors if bar_colors is None else bar_colors
        self.TCGA_data = TCGA_data

    def PanelA(self, save_panel_dir = None):
        #plot heatmap
        self.TCGA_data.sig_heatmap()

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure4A.png', bbox_inches = 'tight', dpi = 300)


    def PanelB(self, colors = None, save_panel_dir = None):
        #plot summary pie
        if colors is None:
            colors = self.palette

        self.TCGA_data.plot_summary_pie(type = 'half', colors = self.pie_colors)

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure4B.svg', bbox_inches = 'tight', dpi = 300)


    def PanelC(self, edgecolor = None, type = 'donut',save_panel_dir = None):
        fig, ax = plt.subplots(figsize = (2, 1))
        if not hasattr(self.TCGA_data, 'enrichr'):
            self.TCGA_data.process_enrichr()


        plot_EnrichR_pies(self.TCGA_data.enrichr, type = type, terms_to_plot = ['Cytoskeleton (GO:0005856)', 'Actin Binding (GO:0003779)', 'Apoptotic Execution Phase R-HSA-75153', 'Oncogenic MAPK Signaling R-HSA-6802957', 'Membrane Trafficking R-HSA-199991'], colors = self.pie_colors, edgecolor = edgecolor, ax = ax)
        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure4C_EnrichR.svg', bbox_inches = 'tight', dpi = 300)

    def PanelD(self, colors = None, save_panel_dir = None):
        fig, ax = plt.subplots(figsize = (1,1))
        self.TCGA_data.plot_annotations(term_to_plot = 'EXONT:Name', colors = self.bar_colors, ax = ax)

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure4D_EXONT.svg', bbox_inches = 'tight', dpi = 300)

    def PanelE_Network(self, ax = None, edgecolor = 'gray', in_domain_edge = None, out_domain_edge = None, in_domain_color = None, out_domain_color = None, interacting_color = 'gray', in_domain_marker = 'X', out_domain_marker = 'o', larger_marker = 5, small_marker = 0.3, save_panel_dir = None):
        if not hasattr(self.TCGA_data, 'interactions'):
            self.TCGA_data.interactions = pd.read_csv(self.TCGA_data.analysis_dir + '/TCGA/PTM_interactions.csv')
            self.TCGA_data.interactions['Regulation Change'] = self.TCGA_data.interactions.apply(lambda x: 1 if x['Type'] != 'DISRUPTS' and x['deltaPSI_MW'] > 0 else 1 if x['Type'] == 'DISRUPTS' and x['deltaPSI_MW'] < 0 else -1, axis = 1)

        
        if ax is None:
            fig, ax = plt.subplots(figsize = (2,2))
        #set node colors
        in_domain_color = self.pie_colors[1] if in_domain_color is None else in_domain_color
        out_domain_color = self.pie_colors[1] if out_domain_color is None else out_domain_color

        in_domain_edge = in_domain_color if in_domain_edge is None else in_domain_edge
        out_domain_edge = out_domain_color if out_domain_edge is None else out_domain_edge

        network_data = self.TCGA_data.interactions.drop_duplicates()
        network_data = network_data.dropna(subset = 'deltaPSI_MW')
        G = nx.from_pandas_edgelist(network_data, source = 'Modified Gene', target = 'Interacting Gene')

        in_domain_data = network_data[network_data['In Domain'] == 1].copy()

        #extract all connected components from graph and plot each
        components = list(nx.connected_components(G))

        subgraph = G.subgraph(components[0])
        #color nodes based on whether ptm is modified Gene (Gene column) and is significantly controlled by splicing
        node_colors = []
        node_sizes = []
        marker_type = []
        in_domain_prots = []
        out_domain_prots = []
        for node in subgraph.nodes:
            if node in in_domain_data['Modified Gene'].unique():
                node_colors.append(in_domain_color)
                marker_type.append(in_domain_marker)
                in_domain_prots.append(node)
                node_sizes.append(larger_marker)
            elif node in network_data['Modified Gene'].unique():
                node_colors.append(out_domain_color)
                marker_type.append(out_domain_marker)
                out_domain_prots.append(node)
                node_sizes.append(larger_marker)
            else:
                node_colors.append(interacting_color)
                marker_type.append(out_domain_marker)
                node_sizes.append(small_marker)

        #adjust line style of edge depending on sign of deltaPSI_MW
        edge_style = []
        for edge in subgraph.edges:
            edge_data = network_data[((network_data['Modified Gene'] == edge[0]) & (network_data['Interacting Gene'] == edge[1])) | ((network_data['Modified Gene'] == edge[1]) & (network_data['Interacting Gene'] == edge[0]))]
            if edge_data['Regulation Change'].values[0] == 1:
                edge_style.append('solid')
            else:
                edge_style.append('dotted')

        np.random.seed(200)
        subgraph.pos = nx.spring_layout(subgraph, seed = 200)

        nx.draw(subgraph, node_size = small_marker, style = edge_style, width = 0.5,font_size = 6,node_color = interacting_color, edge_color = edgecolor, ax = ax)
        nx.draw_networkx_nodes(G, pos = subgraph.pos, nodelist = in_domain_prots, edgecolors = in_domain_edge,linewidths = 0.2,node_shape = in_domain_marker, node_color =in_domain_color, node_size = larger_marker, ax = ax)
        nx.draw_networkx_nodes(G, pos = subgraph.pos, nodelist = out_domain_prots, edgecolors = out_domain_edge, linewidths = 0.2, node_shape = out_domain_marker, node_color = out_domain_color, node_size = larger_marker, ax = ax)

        #add legend for colored nodes
        import matplotlib.lines as mlines
        indomain_node = mlines.Line2D([0], [0], color='w', marker=in_domain_marker,markersize=8,markeredgecolor = in_domain_edge,linewidth = 0.2, markerfacecolor = in_domain_color, label='Spliced Protein (PTM In Domain)')
        outdomain_node = mlines.Line2D([0], [0], color='w', marker=out_domain_marker,markersize=8, markeredgecolor = out_domain_edge, linewidth = 0.2, markerfacecolor=out_domain_color, label='Spliced Protein (PTM Outside Domain)')
        interacting_node = mlines.Line2D([0], [0], color='w', marker='o',markerfacecolor = interacting_color, markersize=5, label='Interacting Protein')
        solid_line = mlines.Line2D([0], [0], color='gray', linestyle = 'solid', label = 'Interaction increases with ESRP1')
        dotted_line = mlines.Line2D([0], [0], color='gray', linestyle = 'dotted', label = 'Interaction decreases with ESRP1')
        handles = [indomain_node, outdomain_node, interacting_node, solid_line, dotted_line]
        ax.legend(handles = handles, loc = 'upper right', ncol = 2, fontsize = 6, bbox_to_anchor = (1.4, 1.25))
        #ax.axis('on')

        #add transparent box surrounding ribosomal proteins
        import matplotlib.patches as patches
        ribo_box = patches.Rectangle((-0.8,-0),0.45,0.5, facecolor = 'none', edgecolor = 'black', linewidth = 0.5)
        ax.add_patch(ribo_box)
        ax.text(-1.1, 0.5, 'Ribosome', fontsize = 7, ha = 'left', va = 'bottom')
       
        #get location of CRK node in plot, create arrow pointing to CRK
        pos = subgraph.pos['CRK']
        ax.annotate('CRK', pos, xytext = (-0.5, -0.5), arrowprops = dict(arrowstyle = '->', color = 'black', linewidth = 1), fontsize = 7)

        pos = subgraph.pos['MAPT']
        ax.annotate('MAPT', pos, xytext = (-0.25, -0.1), arrowprops = dict(arrowstyle = '->', color = 'black', linewidth = 1), fontsize = 7)


        protein = 'EEF1A1'
        pos = subgraph.pos[protein]
        ax.annotate(protein, pos, xytext = (-0.25, 0.7), arrowprops = dict(arrowstyle = '->', color = 'black', linewidth = 1), fontsize = 7)

        protein = 'ABI1'
        pos = subgraph.pos[protein]
        ax.annotate(protein, pos, xytext = (0.5, -0.45), arrowprops = dict(arrowstyle = '->', color = 'black', linewidth = 1), fontsize = 7)

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure4E_Network.svg', bbox_inches = 'tight', dpi = 300)
    
    def PanelE_Degree(self, ax = None, in_domain_color = 'darkorange', out_domain_color = 'darkorange', interacting_color = 'gray', save_panel_dir = None):
        if not hasattr(self.TCGA_data, 'network_stats'):
            self.TCGA_data.network_stats = pd.read_csv(self.TCGA_data.analysis_dir + '/TCGA/PTM_Network_Properties.csv', index_col = 0)

        if ax is None:
            fig, ax = plt.subplots(figsize = (1,1.5))

        plt_data = self.TCGA_data.network_stats.sort_values(by = 'Degree', ascending = False).head(12).iloc[::-1]
        network_data = self.TCGA_data.interactions.drop_duplicates()
        network_data = network_data.dropna(subset = 'deltaPSI_MW')
        in_domain_data = network_data[network_data['In Domain'] == 1]


        #color bars based on whether any PTMs is in domain or not
        colors = []
        hatch = []
        for index, row in plt_data.iterrows():
            if index in in_domain_data['Modified Gene'].unique():
                colors.append(in_domain_color)
                hatch.append('XX')
            elif index in network_data['Modified Gene'].unique():
                colors.append(out_domain_color)
                hatch.append(None)
            else:
                colors.append(interacting_color)
        plt.barh(plt_data.index, plt_data['Degree'], color = colors, hatch = None)

        for index, row in plt_data.iterrows():
            if index in in_domain_data['Modified Gene'].unique():
                plt.text(row['Degree'] - 5, index, 'X', fontsize = 5, weight = 'bold', va = 'center')

        plt.xticks(fontsize = 7)
        plt.yticks(fontsize = 7)
        plt.xlabel('Network Degree', fontsize = 8)

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure4E_Degree.svg', bbox_inches = 'tight', dpi = 300)

    def extract_domain_info(self, domain_name = 'SH2', modification = 'Phosphorylation', residues = 'Y', ptms_to_remove = None):
        motif_data = self.TCGA_data.flanking_sequences.dropna(subset = ['Inclusion Flanking Sequence', 'Exclusion Flanking Sequence'], how = 'all')
        motif_data = motif_data[['Gene', 'Region ID', 'PTM', 'Modification Class', 'Inclusion Flanking Sequence', 'Exclusion Flanking Sequence', 'deltaPSI_MW','Motif in Both', 'Motif only in Inclusion', 'Motif only in Exclusion']]
        domain = motif_data.copy()

        for i, row in domain.iterrows():
            if row['Motif only in Inclusion'] == row['Motif only in Inclusion']:
                if domain_name in row['Motif only in Inclusion']:
                    domain.loc[i, 'Motif only in Inclusion'] = ';'.join([motif for motif in row['Motif only in Inclusion'].split(';') if domain_name in motif])
                else:
                    domain.loc[i, 'Motif only in Inclusion'] = np.nan

            if row['Motif only in Exclusion'] == row['Motif only in Exclusion']:
                if domain_name in row['Motif only in Exclusion']:
                    domain.loc[i, 'Motif only in Exclusion'] = ';'.join([motif for motif in row['Motif only in Exclusion'].split(';') if domain_name in motif])
                else:
                    domain.loc[i, 'Motif only in Exclusion'] = np.nan

        domain = domain.dropna(subset = ["Motif only in Inclusion", 'Motif only in Exclusion'], how = 'all')
        if modification is not None:
            domain = domain[domain['Modification Class'].str.contains(modification)]

        if residues is not None:
            if isinstance(residues, list):
                residues = '|'.join(['_'+ res for res in residues])
            else:
                residues = '_' + residues
            domain = domain[domain['PTM'].str.contains(residues)]

        if ptms_to_remove is not None:
            domain = domain[~domain['PTM'].isin(ptms_to_remove)]

        return domain

    def PanelF(self, type = 'heatmap', elm_data_file = None, save_panel_dir = None):
        if not hasattr(self, 'sh2'):
            self.sh2 = self.extract_domain_info(ptms_to_remove=['Q8NRX4_Y97', 'Q9NRX4_Y97'])

        if not hasattr(self, 'elm'):
            if elm_data_file is None:
                raise ValueError('Please provide ELM class file')
            else:
                self.elm = pd.read_csv(elm_data_file, sep = '\t', header = 5)

        flank_data = self.TCGA_data.flanking_sequences[self.TCGA_data.flanking_sequences['Modification Class'].str.contains('Phosphorylation')].copy()
        flank_data = flank_data[(flank_data['PTM'].isin(self.sh2['PTM'])) & (flank_data['Region ID'].isin(self.sh2['Region ID'])) & (flank_data['Exclusion Flanking Sequence'].isin(self.sh2['Exclusion Flanking Sequence']))]
        position_breakdown = flank_data.copy()
        position_breakdown['Altered_Positions'] = position_breakdown['Altered_Positions'].str.split(';')
        position_breakdown['Residue Changes'] = position_breakdown['Residue Changes'].str.split(';')
        position_breakdown = position_breakdown.explode(['Altered_Positions', 'Residue Changes']).copy()[['Gene', 'PTM','Altered_Positions', 'Residue Changes']]
        position_breakdown['Altered_Positions'] = position_breakdown['Altered_Positions'].astype(int)
        plt_data = position_breakdown.groupby('Altered_Positions').size().sort_values(ascending = False)

        fig, ax = plt.subplots(figsize = (1.9,1))
        fig.subplots_adjust(hspace = 1)

        if type == 'bar':
            ax.bar(plt_data.index, plt_data.values, width = 0.9,color = self.pie_colors[0], edgecolor = 'black', alpha = 0.8)
            ax.set_xlim([-0.2,5.5])
            ax.set_xlabel('Position in Sequence', fontsize = 9)
            ax.set_ylabel('# of Changed\nResidues', fontsize = 9)
            ticks = ax.set_xticks(np.arange(0,6,1))
            tick_labels = ax.set_xticklabels(['pY', '+1', '+2', '+3', '+4', '+5'], fontsize = 7)

            positions = [1,2,3,4,5]
            num_altered = position_breakdown.groupby('PTM').size().sort_values(ascending = False)
            for i, ptm in enumerate(num_altered.index):
                tmp_data = position_breakdown[position_breakdown['PTM'] == ptm].drop_duplicates(subset = ['PTM','Altered_Positions']).reset_index()
                #annotate ptm corresponding to row
                ptm_label = tmp_data['Gene'].unique()[0] + ' ' + tmp_data['PTM'].apply(lambda x: x.split('_')[1]).unique()[0]
                ax.text(5.6, i + 0.5, ptm_label, fontsize = 6, rotation = 0, ha = 'left', va = 'center')

                #annotate sh2 domains for inclusion and exclusion
                trim_sh2 = self.sh2[self.sh2['PTM'] == ptm].squeeze()
                inclusion_label = trim_sh2['Motif only in Inclusion'].split('_')[-1] if trim_sh2['Motif only in Inclusion'] == trim_sh2['Motif only in Inclusion']  else 'None'
                ax.text(9, i + 0.5, inclusion_label, fontsize = 6, ha = 'center', va = 'center')
                exclusion_label = trim_sh2['Motif only in Exclusion'].split('_')[-1] if trim_sh2['Motif only in Exclusion'] == trim_sh2['Motif only in Exclusion']  else 'None'
                ax.text(11.1, i + 0.5, exclusion_label, fontsize = 6, ha = 'center', va = 'center')

                for j, row in tmp_data.iterrows():
                    ax.text(row['Altered_Positions'], i + 0.5, row['Residue Changes'], fontsize = 6, rotation = 0, ha = 'center', va = 'center')

            #add line above each text label as a header
            ax.text(5.6, 5, 'Phosphosite', weight = 'bold', fontsize = 7)
            ax.text(9, 5, 'Inclusion\nSH2\nMotif', weight = 'bold', fontsize = 7, ha = 'center')
            ax.text(11.1, 5, 'Exclusion\nSH2\nMotif', weight = 'bold', fontsize = 7, ha = 'center')
        elif type == 'heatmap':
            position_matrix = position_breakdown.pivot(columns = 'Altered_Positions', index = 'PTM', values= 'Residue Changes')
            for i, pos in zip(range(6),range(0, 6)):
                if pos not in position_matrix.columns:
                    position_matrix.insert(i, pos, np.nan)

            #convert ptm to gene name from uniprot
            label_to_ptm = {POSE_config.uniprot_to_gene[ptm.split('_')[0]].split(' ')[0]+ ' ' + ptm.split('_')[1]:ptm for ptm in position_matrix.index}
            position_matrix.index = [POSE_config.uniprot_to_gene[ptm.split('_')[0]].split(' ')[0]+ ' ' + ptm.split('_')[1] for ptm in position_matrix.index]

            #convert matrix to binary values
            position_values = position_matrix.applymap(lambda x: 1 if x == x else np.nan).sort_values(by = 5)
            position_matrix = position_matrix.loc[position_values.index]
            #plot heatmap
            sns.heatmap(position_values, cmap = 'Greens', vmin = 0, vmax = 2, ax = ax, cbar = False, linewidths = 0.5, linecolor = 'black', yticklabels=False)
            ax.set_facecolor("lightgrey")
            for i in range(position_values.shape[0]):
                for j in range(position_values.shape[1]):
                    if position_values.iloc[i,j] == 1:
                        ax.text(j+0.5, i+0.5, position_matrix.iloc[i,j], ha = 'center', va = 'center', fontsize = 6)
            ax.set_xticklabels(['pY','+1','+2','+3','+4','+5'], fontsize = 7)
            ax.set_xlabel('')
            ax.tick_params(axis = 'y', labelsize = 6)
            #ax.set_title('Disrupted Canonical SH2 Binding Motif', fontsize = 9)

            positions = [1,2,3,4,5]
            for i, label in enumerate(position_matrix.index):
                ptm = label_to_ptm[label]
                tmp_data = position_breakdown[position_breakdown['PTM'] == ptm].drop_duplicates(subset = ['PTM','Altered_Positions']).reset_index()
                #annotate ptm corresponding to row
                ptm_label = tmp_data['Gene'].unique()[0] + ' ' + tmp_data['PTM'].apply(lambda x: x.split('_')[1]).unique()[0]
                ax.text(6.05, i + 0.5, ptm_label, fontsize = 6, rotation = 0, ha = 'left', va = 'center')

                #annotate sh2 domains for inclusion and exclusion
                trim_sh2 = self.sh2[self.sh2['PTM'] == ptm].squeeze()
                inclusion_label = trim_sh2['Motif only in Inclusion'].split('_')[-1] if trim_sh2['Motif only in Inclusion'] == trim_sh2['Motif only in Inclusion']  else 'None'
                ax.text(9.6, i + 0.5, inclusion_label, fontsize = 6, ha = 'center', va = 'center')
                exclusion_label = trim_sh2['Motif only in Exclusion'].split('_')[-1] if trim_sh2['Motif only in Exclusion'] == trim_sh2['Motif only in Exclusion']  else 'None'
                ax.text(11.2, i + 0.5, exclusion_label, fontsize = 6, ha = 'center', va = 'center')
                
                #label cells, bolding those that disrupt the motif
                ex_flank = trim_sh2['Exclusion Flanking Sequence']
                ex_motif = trim_sh2["Motif only in Exclusion"]
                in_motif = trim_sh2["Motif only in Inclusion"]
                in_flank = trim_sh2['Inclusion Flanking Sequence']
                positions = position_matrix.loc[label]
                for j, change in enumerate(positions.values):
                    if change == change:
                        important = False
                        if ex_motif == ex_motif:
                            reg_ex = self.elm.loc[self.elm['ELMIdentifier'] == ex_motif, 'Regex'].values[0]
                            inc_change = change.split('->')[0]
                            new_flank = list(ex_flank)
                            new_flank[j+5] = inc_change
                            new_flank = ''.join(new_flank)
                            if not re.search(reg_ex, new_flank.upper()):
                                important = True
                        
                        if in_motif == in_motif:
                            reg_ex = self.elm.loc[self.elm['ELMIdentifier'] == in_motif, 'Regex'].values[0]
                            ex_change = change.split('->')[1]
                            new_flank = list(in_flank)
                            new_flank[j+5] = ex_change
                            new_flank = ''.join(new_flank)
                            if not re.search(reg_ex, new_flank.upper()):
                                important = True
                            
                        if important:
                            ax.text(j+0.5, i + 0.5, change, fontsize = 6, rotation = 0, ha = 'center', va = 'center', weight = 'bold', color = 'black')
                        else:
                            ax.text(j+0.5, i + 0.5, change, fontsize = 6, rotation = 0, ha = 'center', va = 'center', color = 'gray')

            #add line above each text label as a header
            ax.text(5.5, -0.2, 'Phosphosite', weight = 'bold', fontsize = 7)
            ax.text(10.2, -0.2, 'Inclusion\nSH2\nMotif', weight = 'bold', fontsize = 7, ha = 'right')
            ax.text(10.5, -0.2, 'Exclusion\nSH2\nMotif', weight = 'bold', fontsize = 7, ha = 'left')


        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure4F_SH2.svg', bbox_inches = 'tight', dpi = 300)

    def PanelG(self, save_panel_dir = None):
        fig, ax = plt.subplots(figsize = (2,1.5), nrows = 2, sharex = True, height_ratios = [0.7,1])
        fig.subplots_adjust(hspace = 0)

        relevant_annotated_ptms = self.TCGA_data.extract_ptms_related_to_term('Combined:Kinase')[0]

        pivot_table = stat_utils.constructPivotTable(relevant_annotated_ptms, 'Combined:Kinase', collapse_on_similar = False)
        pivot_table.columns = [col.replace('_',' ') for col in pivot_table.columns]

        if not hasattr(self.TCGA_data, 'high_ptm_list') or not hasattr(self.TCGA_data, 'low_ptm_list') or not hasattr(self.TCGA_data, 'flank_ptm_list') or not hasattr(self.TCGA_data, 'kstar_results'):
            high_ptms = self.TCGA_data.sig_ptms.loc[self.TCGA_data.sig_ptms['ESRP1_MW'] == 'High']
            self.TCGA_data.high_ptm_list = high_ptms.apply(lambda x: x['UniProtKB Accession'] + '_' + x['Residue']+ str(int(float(x['PTM Position in Canonical Isoform']))) if x['PTM Position in Canonical Isoform'] == x['PTM Position in Canonical Isoform'] else x['Source of PTM'].split(';')[0], axis = 1).unique()
            low_ptms = self.TCGA_data.sig_ptms.loc[self.TCGA_data.sig_ptms['ESRP1_MW'] == 'Low']
            self.TCGA_data.low_ptm_list = low_ptms.apply(lambda x: x['UniProtKB Accession'] + '_' + x['Residue']+ str(int(float(x['PTM Position in Canonical Isoform']))) if x['PTM Position in Canonical Isoform'] == x['PTM Position in Canonical Isoform'] else x['Source of PTM'].split(';')[0], axis = 1).unique()
            relevant_flanks = self.TCGA_data.annotated_ptms[self.TCGA_data.annotated_ptms['Source of PTM'].isin(self.TCGA_data.flanking_sequences['Source of PTM'])].copy()
            flank_ptm_list =  relevant_flanks.apply(lambda x: x['UniProtKB Accession'] + '_' + x['Residue']+ str(int(float(x['PTM Position in Canonical Isoform']))) if x['PTM Position in Canonical Isoform'] == x['PTM Position in Canonical Isoform'] else x['Source of PTM'].split(';')[0], axis = 1)
            self.TCGA_data.flank_ptm_list = list(set(flank_ptm_list).difference(self.TCGA_data.high_ptm_list).difference(self.TCGA_data.low_ptm_list))

        if not hasattr(self.TCGA_data, 'kstar_results'):  
            self.TCGA_data.process_kinase_activities()          

        top_terms = 10
        all_ptms = pivot_table.loc[:,~pivot_table.columns.str.contains('GROUP')]
        all_ptms = all_ptms[all_ptms.index.isin(self.TCGA_data.flank_ptm_list)].count().sort_values(ascending = True).iloc[-1*top_terms:]
        all_ptms = all_ptms[all_ptms > 1]
        #restrict to kinases in kstar data
        all_ptms = all_ptms[all_ptms.index.isin(self.TCGA_data.kstar_results.index)]

        #split into high and low ptms
        low_ptms_data = pivot_table[pivot_table.index.isin(self.TCGA_data.low_ptm_list)].count()
        for idx in all_ptms.index:
            if idx not in low_ptms_data.index:
                low_ptms_data[idx] = 0
        low_ptms_data = low_ptms_data.loc[all_ptms.index]
        high_ptms_data = pivot_table[pivot_table.index.isin(self.TCGA_data.high_ptm_list)].count()
        for idx in all_ptms.index:
            if idx not in high_ptms_data.index:
                high_ptms_data[idx] = 0
        high_ptms_data = high_ptms_data.loc[all_ptms.index]

        from kstar import plot
        plt_data = self.TCGA_data.kstar_results.loc[[kin for kin in all_ptms.index if kin in self.TCGA_data.kstar_results.index], ['High', 'Low']]
        #add in 0 for missing kinases
        plt_data = plt_data.rename({'High':'Included\nEnrichment', 'Low':'Excluded\nEnrichment'}, axis = 1)
        dots = plot.DotPlot(-np.log10(plt_data).T, plt_data.T, figsize = (1,4),  colormap = {0: '#6b838f', 1: self.pie_colors[1]})
        #dots.drop_kinases_with_no_significance()
        dots.dotplot(color_legend = False, size_legend = False, ax = ax[1])
        ax[1].tick_params(axis = 'x', labelsize = 8, rotation = 0)
        ax[1].tick_params(axis = 'y', labelsize = 8)

        ax[0].bar(ax[1].get_xticks(), low_ptms_data.values, width = 10, edgecolor = 'black', color = self.bar_colors[0])
        ax[0].bar(ax[1].get_xticks(), high_ptms_data.values, bottom = low_ptms_data.values, width = 10, color = self.bar_colors[1], edgecolor = 'black')
        ax[0].set_yticks([2,4,6])
        ax[0].tick_params(axis = 'y', labelsize = 7)
        ax[0].set_ylabel('Number of\nKnown\nSubstrates', fontsize = 8, rotation = 0, ha = 'right', va = 'center')

        #make custom legends
        import matplotlib.patches as mpatches
        handles = [mpatches.Patch(facecolor = self.bar_colors[0], edgecolor = 'black', label = 'Excluded'), mpatches.Patch(facecolor = self.bar_colors[1], edgecolor = 'black', label = 'Included')]
        ax[0].legend(handles = handles, ncol = 1, loc = 'lower left', bbox_to_anchor = (-0.2,1), fontsize = 7, title = 'Type of Impact', title_fontsize = 8)

        #custom legend indicating significance with circles (blue is significant)
        from matplotlib.lines import Line2D
        handles = [Line2D([0], [0], marker='o', markerfacecolor = self.pie_colors[1], color='w', label='Significant', markersize=10), Line2D([0], [0], marker='o',markerfacecolor='#6b838f', color='w', label='Not Enriched', markersize=5)]
        ax[1].legend(handles = handles, ncol = 1, loc = 'lower left', bbox_to_anchor = (0.4,1.7), fontsize = 7, title = 'KSTAR Enrichment', title_fontsize = 8)
        
        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure4G_KS.svg', bbox_inches = 'tight', dpi = 300)
        

    def PanelH(self, save_panel_dir = None):
        if not hasattr(self, 'kl_data'):
            flank_data = self.TCGA_data.flanking_sequences.copy()
            flank_data['Label'] = flank_data['Region ID']+';'+flank_data['PTM']
            flank_data = flank_data[['Label', 'deltaPSI_MW']].drop_duplicates()
            flank_data = flank_data.groupby('Label', as_index = False).mean()

            percentile_differences_ST = pd.read_csv(self.TCGA_data.analysis_dir + '/TCGA/Kinase_Enrichment/KinaseLibrary/percentile_differences_ST.tsv', index_col = 0)
            percentile_differences_ST = percentile_differences_ST.melt(ignore_index = False)
            percentile_differences_ST['Mod'] = 'ST'
            percentile_differences_Y = pd.read_csv(self.TCGA_data.analysis_dir + '/TCGA/Kinase_Enrichment/KinaseLibrary/percentile_differences_Y.tsv', index_col = 0)
            percentile_differences_Y = percentile_differences_Y.melt(ignore_index = False)
            percentile_differences_Y["Mod"] = 'Y'
            percentile_differences = pd.concat([percentile_differences_Y, percentile_differences_ST])
            percentile_differences = percentile_differences.rename({'value':'Percentile Change'}, axis = 1).reset_index()

            inclusion_ST = pd.read_csv(self.TCGA_data.analysis_dir + '/TCGA/Kinase_Enrichment/KinaseLibrary/inclusion_scores_ST.tsv', index_col = 0)
            inclusion_ST = inclusion_ST.melt(ignore_index = False)
            inclusion_ST['Mod'] = 'ST'
            inclusion_Y = pd.read_csv(self.TCGA_data.analysis_dir + '/TCGA/Kinase_Enrichment/KinaseLibrary/inclusion_scores_Y.tsv', index_col = 0)
            inclusion_Y = inclusion_Y.melt(ignore_index = False)
            inclusion_Y["Mod"] = 'Y'
            inclusion = pd.concat([inclusion_Y,inclusion_ST])
            inclusion = inclusion.rename({'value':'Inclusion Percentile'}, axis = 1).reset_index()

            kl_data = pd.merge(inclusion, percentile_differences, on = ['variable', 'Label'])
            kl_data = kl_data.merge(flank_data, on = 'Label')
            kl_data['Change Magnitude'] =  kl_data['Percentile Change'] * kl_data['deltaPSI_MW']
            self.kl_data = kl_data

        kinase_of_interest = ['ABL','AKT1','PKACA','SGK1']
        koi_differences = self.kl_data[self.kl_data['variable'].isin(kinase_of_interest)].copy()

        fig, ax = plt.subplots(figsize = (1.5,1.5))
        koi_differences = koi_differences.sort_values(by = 'variable', ascending = False).rename({'PKACA':"PRKACA"})
        sns.swarmplot(data = koi_differences, x = 'Change Magnitude', y = 'variable', ax = ax, s = 1.5, color = self.pie_colors[2])
        ax.set_xlabel('Kinase Interaction\nChange', fontsize = 8)
        ax.set_ylabel('')
        ax.tick_params(labelsize = 8)
        ax.set_xlim([-12,12])

        #add indicator of direction
        ax.text(1, -0.5, 'High\nESRP1', fontsize = 7, va = 'bottom')
        ax.text(-1, -0.5, 'Low\nESRP1', fontsize = 7, va = 'bottom', ha = 'right')
        ax.text(0, -1.4, 'Favors', fontsize = 7,weight='bold', va = 'center', ha = 'center')

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure4H_KL.svg', bbox_inches = 'tight', dpi = 300)


    def PanelI(self, save_panel_dir = None):
        pass


    def PanelJ(self, protein1 = 'ESRP1', type1 = 'high', protein2 = 'PTEN', type2 = 'low',colors = None, leg_loc = None, leg_fontsize = None, title = None, ax = None, save_panel_dir = None):
        if not hasattr(self.TCGA_data, 'survival'):
            self.TCGA_data.load_patient_data()

        #extract mrna_data

        mrna_data = self.TCGA_data.mRNA.copy()
        mrna_data['Edited Patient ID'] = mrna_data['SAMPLE_ID'].apply(lambda x: '-'.join(x.split('-')[0:3])).to_list()
        mrna_data = mrna_data.set_index('Edited Patient ID')
        mrna_data = mrna_data.drop(['STUDY_ID', 'SAMPLE_ID'], axis = 1)
        #mrna_data = mrna_data.loc[[i for i in mrna_data.index if i in self.TCGA_data.survival.index]]
    

        #get high and low patients
        high = (mrna_data > self.TCGA_data.cutoff)*1
        low = (mrna_data < -1*self.TCGA_data.cutoff)*1


        #extract patients
        if type1 == 'high':
            patients_1 = high[high[protein1] == 1].index
        elif type1 == 'low':
            patients_1 = low[low[protein1] == 1].index
        else:
            raise ValueError('type must be high or low')
        
        if type2 == 'high':
            patients_2 = high[high[protein2] == 1].index
        elif type2 == 'low':
            patients_2 = low[low[protein2] == 1].index
        else:
            raise ValueError('type must be high or low')
        
        if colors is None:
            colors = np.repeat('black', 3)
        fig, ax = plt.subplots(figsize = (1, 1.6))
        
        group1_and_group2 = list(set(patients_1).intersection(patients_2))
        group1_only = list(set(patients_1).difference(patients_2))
        group2_only = list(set(patients_2).difference(patients_1)) 
        neither_group = list(set(mrna_data.index).difference(set(group1_and_group2 + group1_only + group2_only)))

        kmf = KaplanMeierFitter()
        plt_data1 = [self.TCGA_data.survival[group1_and_group2], self.TCGA_data.status[group1_and_group2]]
        kmf1 = kmf.fit(plt_data1[0].values, plt_data1[1].values, label = f'{protein1} {type1}, {protein2} {type2}')
        kmf1.plot(ax = ax, ci_show = False, linestyle = '-', color = colors[0])

        plt_data2 = [self.TCGA_data.survival[group1_only], self.TCGA_data.status[group1_only]]
        kmf2 = kmf.fit(plt_data2[0].values, plt_data2[1].values, label = f'{protein1} {type1} only')
        kmf2.plot(ax = ax, ci_show = False, linestyle = '--', color = colors[1])

        plt_data3 = [self.TCGA_data.survival[group2_only], self.TCGA_data.status[group2_only]]
        kmf3 = kmf.fit(plt_data3[0].values, plt_data3[1].values, label = f'{protein2} {type2} only')
        kmf3.plot(ax = ax, ci_show = False, linestyle =  ':', color = colors[2])

        #plt_data4 = [self.TCGA_data.survival[neither_group], self.TCGA_data.status[neither_group]]
        #kmf4 = kmf.fit(plt_data4[0].values, plt_data4[1].values, label = 'Other')
        #kmf4.plot(ax = ax, ci_show = False, linestyle = ':')

        # Customize the plot
        if title:
            ax.set_title(f'Kaplan-Meier Survival Curve: {protein1}-{type1}, {protein2}-{type2}')
        elif isinstance(title, str):
            ax.set_title(title)
            
        ax.set_xlabel('Survival\nMonths', fontsize = 9)
        #convert yticks to percentages
        ax.yaxis.set_major_formatter(mtick.PercentFormatter(1))
        ax.tick_params(labelsize = 7)

        plt.ylabel('Progression Free\nSurvival (%)', fontsize = 9)
        if leg_fontsize is None:
            leg_fontsize = 6
        
        if leg_loc is None:
            ax.legend(fontsize = leg_fontsize)
        else:
            ax.legend(fontsize = leg_fontsize, loc = leg_loc)

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure4J_KM.svg', bbox_inches = 'tight', dpi = 300)

class Figure5:
    def __init__(self, TCGA_data, top_kinases = 8, min_subs = 2, include_flank = True, pie_colors = None, bar_colors = None):
        self.tcga_data = TCGA_data
        self.pie_colors = self.tcga_data.pie_colors if pie_colors is None else pie_colors
        self.bar_colors = self.tcga_data.bar_colors if bar_colors is None else bar_colors

        if not hasattr(self.tcga_data, 'kstar_results'):  
            self.tcga_data.process_kinase_activities()   

        #get known kinase info
        relevant_annotated_ptms = self.tcga_data.extract_ptms_related_to_term()[0]
        pivot_table = stat_utils.constructPivotTable(relevant_annotated_ptms, 'Combined:Kinase', collapse_on_similar = False)
        pivot_table.columns = [col.replace('_',' ') for col in pivot_table.columns]
        self.known_kinase_pivot = pivot_table

        #extract
        all_subs = pivot_table.loc[:,~pivot_table.columns.str.contains('GROUP')]
        if include_flank:
            all_subs = all_subs.count().sort_values(ascending = True).iloc[-1*top_kinases:]
        else:
            all_subs = all_subs[~all_subs.index.isin(self.tcga_data.flank_ptm_list)].count().sort_values(ascending = True).iloc[-1*top_kinases:]
        all_subs = all_subs[all_subs >= min_subs]
        #restrict to kinases in kstar data
        all_subs = all_subs[all_subs.index.isin(self.tcga_data.kstar_results.index)]
        self.known_substrates = all_subs

    def PanelA(self, ax = None, save_panel_dir = None, top_terms = 8, min_subs = 2, include_flank = True):
        if ax is None:
            fig, ax = plt.subplots(figsize = (2,1))


        if not hasattr(self.tcga_data, 'high_ptm_list') or not hasattr(self.tcga_data, 'low_ptm_list') or not hasattr(self.tcga_data, 'flank_ptm_list') or not hasattr(self.tcga_data, 'kstar_results'):
            high_ptms = self.tcga_data.sig_ptms.loc[self.tcga_data.sig_ptms['ESRP1_MW'] == 'High']
            self.tcga_data.high_ptm_list = high_ptms.apply(lambda x: x['UniProtKB Accession'] + '_' + x['Residue']+ str(int(float(x['PTM Position in Canonical Isoform']))) if x['PTM Position in Canonical Isoform'] == x['PTM Position in Canonical Isoform'] else x['Source of PTM'].split(';')[0], axis = 1).unique()
            low_ptms = self.tcga_data.sig_ptms.loc[self.tcga_data.sig_ptms['ESRP1_MW'] == 'Low']
            self.tcga_data.low_ptm_list = low_ptms.apply(lambda x: x['UniProtKB Accession'] + '_' + x['Residue']+ str(int(float(x['PTM Position in Canonical Isoform']))) if x['PTM Position in Canonical Isoform'] == x['PTM Position in Canonical Isoform'] else x['Source of PTM'].split(';')[0], axis = 1).unique()
            relevant_flanks = self.tcga_data.annotated_ptms[self.tcga_data.annotated_ptms['Source of PTM'].isin(self.tcga_data.flanking_sequences['Source of PTM'])].copy()
            flank_ptm_list =  relevant_flanks.apply(lambda x: x['UniProtKB Accession'] + '_' + x['Residue']+ str(int(float(x['PTM Position in Canonical Isoform']))) if x['PTM Position in Canonical Isoform'] == x['PTM Position in Canonical Isoform'] else x['Source of PTM'].split(';')[0], axis = 1)
            self.tcga_data.flank_ptm_list = list(set(flank_ptm_list).difference(self.tcga_data.high_ptm_list).difference(self.tcga_data.low_ptm_list))

        if not hasattr(self.tcga_data, 'kstar_results'):  
            self.tcga_data.process_kinase_activities()          

        #restrict to kinases in kstar data
        

        #split into high and low ptms
        low_ptms_data = self.known_kinase_pivot[self.known_kinase_pivot.index.isin(self.tcga_data.low_ptm_list)].count()
        for idx in self.known_substrates.index:
            if idx not in low_ptms_data.index:
                low_ptms_data[idx] = 0
        low_ptms_data = low_ptms_data.loc[self.known_substrates.index]
        high_ptms_data = self.known_kinase_pivot[self.known_kinase_pivot.index.isin(self.tcga_data.high_ptm_list)].count()
        for idx in self.known_substrates.index:
            if idx not in high_ptms_data.index:
                high_ptms_data[idx] = 0
        high_ptms_data = high_ptms_data.loc[self.known_substrates.index]


        ax.bar(self.known_substrates.index, low_ptms_data.values, edgecolor = 'black', color = self.bar_colors[0])
        ax.bar(self.known_substrates.index, high_ptms_data.values, bottom = low_ptms_data.values, color = self.bar_colors[1], edgecolor = 'black')
        if include_flank:
            flank_ptms_data = self.known_kinase_pivot[self.known_kinase_pivot.index.isin(self.tcga_data.flank_ptm_list)].count()
            for idx in self.known_substrates.index:
                if idx not in flank_ptms_data.index:
                    flank_ptms_data[idx] = 0
            flank_ptms_data = flank_ptms_data.loc[self.known_substrates.index]
            ax.bar(self.known_substrates.index, flank_ptms_data.values, bottom = low_ptms_data.values + high_ptms_data.values, color = self.bar_colors[2], edgecolor = 'black')
        
        ax.set_yticks([0,2,4,6])
        ax.tick_params(labelsize = 8)
        plt.xticks(rotation = 35, ha = 'right')
        ax.set_ylabel('Number of\nKnown\nSubstrates', fontsize = 8, rotation = 0, ha = 'right', va = 'center')

        #make custom legends
        import matplotlib.patches as mpatches
        handles = [mpatches.Patch(facecolor = self.bar_colors[0], edgecolor = 'black', label = 'Excluded'), mpatches.Patch(facecolor = self.bar_colors[1], edgecolor = 'black', label = 'Included'), mpatches.Patch(facecolor = self.bar_colors[2], edgecolor = 'black', label = 'Altered Flank')]
        ax.legend(handles = handles, ncol = 3, loc = 'lower left', bbox_to_anchor = (-0.5,1.05), fontsize = 7, title = 'Type of Impact', title_fontsize = 8)

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure5A_KnownKS.svg', bbox_inches = 'tight', dpi = 300)
        
    def PanelB(self, ax = None, save_panel_dir = None):
        if ax is None:
            fig, ax = plt.subplots(figsize = (2,0.8))

        from kstar import plot
        plt_data = self.tcga_data.kstar_results.loc[[kin for kin in self.known_substrates.index if kin in self.tcga_data.kstar_results.index], ['High', 'Low']]
        #add in 0 for missing kinases
        plt_data = plt_data.rename({'High':'Included\nSites', 'Low':'Excluded\nSites'}, axis = 1)
        dots = plot.DotPlot(-np.log10(plt_data).T, plt_data.T, figsize = (1,4),  colormap = {0: '#6b838f', 1: self.pie_colors[1]})
        #dots.drop_kinases_with_no_significance()
        dots.dotplot(color_legend = False, size_legend = False, ax = ax)
        ax.tick_params(axis = 'x', labelsize = 7, rotation = 35)
        plt.xticks(ha = 'right')
        ax.tick_params(axis = 'y', labelsize = 7)

        #custom legend indicating significance with circles (blue is significant)
        from matplotlib.lines import Line2D
        handles = [Line2D([0], [0], marker='o', markerfacecolor = self.pie_colors[1], color='w', label='Significant', markersize=10), Line2D([0], [0], marker='o',markerfacecolor='#6b838f', color='w', label='Not Enriched', markersize=5)]
        ax.legend(handles = handles, ncol = 2, loc = 'lower left', bbox_to_anchor = (-0.2,1), fontsize = 7, title = 'KSTAR Enrichment', title_fontsize = 8)
        
        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure5B_KSTAR.svg', bbox_inches = 'tight', dpi = 300)

    def PanelC(self, save_panel_dir = None):
        """
        Changes to Kinase Library scores for AKT1,SGK1,PKACA, and ABL
        """
        #if not yet loaded, load kinase library data, and combine into plottable dataframe
        if not hasattr(self, 'kl_data'):
            flank_data = self.tcga_data.flanking_sequences.copy()
            flank_data['Label'] = flank_data['Region ID']+';'+flank_data['PTM']
            flank_data = flank_data[['Label', 'deltaPSI_MW']].drop_duplicates()
            flank_data = flank_data.groupby('Label', as_index = False).mean()

            percentile_differences_ST = pd.read_csv(self.tcga_data.analysis_dir + '/TCGA/Kinase_Enrichment/KinaseLibrary/percentile_differences_ST.tsv', index_col = 0)
            percentile_differences_ST = percentile_differences_ST.melt(ignore_index = False)
            percentile_differences_ST['Mod'] = 'ST'
            percentile_differences_Y = pd.read_csv(self.tcga_data.analysis_dir + '/TCGA/Kinase_Enrichment/KinaseLibrary/percentile_differences_Y.tsv', index_col = 0)
            percentile_differences_Y = percentile_differences_Y.melt(ignore_index = False)
            percentile_differences_Y["Mod"] = 'Y'
            percentile_differences = pd.concat([percentile_differences_Y, percentile_differences_ST])
            percentile_differences = percentile_differences.rename({'value':'Percentile Change'}, axis = 1).reset_index()

            inclusion_ST = pd.read_csv(self.tcga_data.analysis_dir + '/TCGA/Kinase_Enrichment/KinaseLibrary/inclusion_scores_ST.tsv', index_col = 0)
            inclusion_ST = inclusion_ST.melt(ignore_index = False)
            inclusion_ST['Mod'] = 'ST'
            inclusion_Y = pd.read_csv(self.tcga_data.analysis_dir + '/TCGA/Kinase_Enrichment/KinaseLibrary/inclusion_scores_Y.tsv', index_col = 0)
            inclusion_Y = inclusion_Y.melt(ignore_index = False)
            inclusion_Y["Mod"] = 'Y'
            inclusion = pd.concat([inclusion_Y,inclusion_ST])
            inclusion = inclusion.rename({'value':'Inclusion Percentile'}, axis = 1).reset_index()

            kl_data = pd.merge(inclusion, percentile_differences, on = ['variable', 'Label'])
            kl_data = kl_data.merge(flank_data, on = 'Label')
            kl_data['Change Magnitude'] =  kl_data['Percentile Change'] * kl_data['deltaPSI_MW']
            self.kl_data = kl_data

        #extract kinases of interest
        kinase_of_interest = ['ABL','AKT1','PKACA','SGK1']
        koi_differences = self.kl_data[self.kl_data['variable'].isin(kinase_of_interest)].copy()

        #plot swarm plot
        fig, ax = plt.subplots(figsize = (1.5,1.5))
        koi_differences = koi_differences.sort_values(by = 'variable', ascending = False).rename({'PKACA':"PRKACA"})
        sns.swarmplot(data = koi_differences, x = 'Change Magnitude', y = 'variable', ax = ax, s = 1.5, color = self.pie_colors[2])
        ax.set_xlabel('Kinase Interaction\nChange', fontsize = 8)
        ax.set_ylabel('')
        ax.tick_params(labelsize = 8)
        ax.set_xlim([-12,12])

        #add indicator of direction
        ax.text(1, -0.5, 'High\nESRP1', fontsize = 7, va = 'bottom')
        ax.text(-1, -0.5, 'Low\nESRP1', fontsize = 7, va = 'bottom', ha = 'right')
        ax.text(0, -1.4, 'Favors', fontsize = 7,weight='bold', va = 'center', ha = 'center')

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure4H_KL.svg', bbox_inches = 'tight', dpi = 300)


    def PanelD(self, save_panel_dir = None):
        """
        Plot TSC2 S981 PSI across tcga datasets and siRNA
        """
        #load prostate PTM data
        prostate_high = self.tcga_data.sig_ptms.loc[self.tcga_data.sig_ptms['PTM'] == 'P49815_S981', self.tcga_data.ESRP1_high].melt(var_name = 'Patient', value_name = 'Percent Spliced In (PSI)')
        prostate_high['Status'] = 'High'
        prostate_low = self.tcga_data.sig_ptms.loc[self.tcga_data.sig_ptms['PTM'] == 'P49815_S981', self.tcga_data.ESRP1_low].melt(var_name = 'Patient', value_name = 'Percent Spliced In (PSI)')
        prostate_low['Status'] = 'Low' 
        prostate = pd.concat([prostate_low, prostate_high])
        prostate['Data Type'] = 'Prostate'

        #load sirna data
        yang_ptms = pd.read_csv(self.tcga_data.analysis_dir + "/Yang2016/spliced_ptms_Yang2016.csv")
        yang_dpsi = yang_ptms.loc[yang_ptms['Source of PTM'] == 'P49815-1_S981', 'dPSI'].values[0]

        #calculate variance of TSC2 S981 PSI in prostate
        prostate_high_variance = self.tcga_data.sig_ptms.loc[self.tcga_data.sig_ptms['PTM'] == 'P49815_S981', self.tcga_data.ESRP1_high].std(axis = 1).values[0]
        prostate_low_variance = self.tcga_data.sig_ptms.loc[self.tcga_data.sig_ptms['PTM'] == 'P49815_S981', self.tcga_data.ESRP1_low].std(axis = 1).values[0]
        prostate_variance = np.sqrt(prostate_high_variance**2 + prostate_low_variance**2)

        prostate = self.tcga_data.sig_ptms.loc[self.tcga_data.sig_ptms['PTM'] == 'P49815_S981', 'deltaPSI_MW']

        #load and process breast data
        if not hasattr(self, 'breast_TSC2'):
            breast = pd.read_csv(self.tcga_data.analysis_dir + '/TCGA/PSI_ptms_Breast.csv')
            self.breast_TSC2 = breast.loc[breast['PTM'] == 'P49815_S981.0']
                #load ESRP1 expression data
            mRNA = pd.read_csv(self.tcga_data.database_dir + f"/TCGA/Breast/cBio/mRNA/Breast_mRNA expression z-scores relative to all samples (log RNA Seq V2 RSEM).txt", sep = '\t') # Z-score of ESPR1 
            mRNA = mRNA.dropna(subset = 'ESRP1')
                    #remove patients with no measured ESRP1 mRNA from splice data, or vice versa
            mRNA['Edited Patient ID'] = mRNA['SAMPLE_ID'].apply(lambda x: '_'.join(x.split('-')[0:3])).to_list()
            patients_to_drop = [col for col in breast.columns if col not in mRNA['Edited Patient ID'].values and 'TCGA' in col]
            mRNA.set_index('Edited Patient ID', inplace = True)
            self.breast_TSC2 = self.breast_TSC2.drop(columns = patients_to_drop)
                        #remove patients with no measured splice data from ESRP1 data
            patients_to_drop = [col for col in mRNA.index if col not in breast.columns]
            mRNA = mRNA[~mRNA.index.isin(patients_to_drop)].copy()
            ESPR_low = mRNA[mRNA["ESRP1"] < -1]
            self.breast_ESRP1_low_id = ESPR_low["SAMPLE_ID"].str.split("-").apply(lambda x: x[0:3]).apply(lambda x: '_'.join(x)).to_list()
            ESPR_high = mRNA[mRNA["ESRP1"] > 1]
            self.breast_ESRP1_high_id = ESPR_high["SAMPLE_ID"].str.split("-").apply(lambda x: x[0:3]).apply(lambda x: '_'.join(x)).to_list()


        #load and process breast data
        breast = self.breast_TSC2['deltaPSI_MW'].values[0]
        breast_high_variance = self.breast_TSC2[self.breast_ESRP1_high_id].std(axis = 1).values[0]
        breast_low_variance = self.breast_TSC2[self.breast_ESRP1_low_id].std(axis = 1).values[0]
        breast_variance = np.sqrt(breast_high_variance**2 + breast_low_variance**2)

        fig, ax = plt.subplots(figsize = (1.2,1.5), sharey =True,ncols = 2, width_ratios = [0.3,1])
        fig.subplots_adjust(wspace = 0)

        #siRNA data
        ax[0].scatter(['Yang\net al.'], [yang_dpsi*-1], color = 'black')
        ax[0].set_ylim([-0.5,0.5])
        ax[0].tick_params(axis = 'both', labelsize = 8)
        ax[0].set_ylabel('$\Delta$PSI of TSC2 S981\nwith increased\nESRP1 Expression', fontsize = 8)
        ax[0].text(0.05, 0.5, 'siRNA', fontsize = 8, ha = 'right', va = 'bottom', weight = 
        'bold')

        #TCGA data
        ax[1].scatter(['Prostate'], prostate, color = 'black')
        ax[1].plot([0,0], [prostate - prostate_variance, prostate + prostate_variance], color = 'black')
        ax[1].scatter(['Breast'], breast, color = 'black')
        ax[1].plot([1,1], [breast - breast_variance, breast + breast_variance], color = 'black')
        ax[1].set_xlim([-0.5,1.5])
        ax[1].tick_params(axis = 'y', labelsize = 6)
        plt.xticks(fontsize = 8, ha = 'left', rotation = 330)
        ax[1].set_ylim([-0.5,0.5])
        ax[1].text(0.5, 0.5, 'TCGA\nDataset', fontsize = 8, horizontalalignment = 'center', va = 'bottom', weight = 'bold')
        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure5D_TSC2.svg', bbox_inches = 'tight', dpi = 300)

    def PanelE(self, protein1 = 'ESRP1', type1 = 'high', protein2 = 'PTEN', type2 = 'low',colors = None, leg_loc = None, leg_fontsize = None, title = None, ax = None, save_panel_dir = None):
        """
        Prostate cancer survival based on ESRP1 and PTEN expression
        """
        if not hasattr(self.tcga_data, 'survival'):
            self.tcga_data.load_patient_data()

        #extract mrna_data

        mrna_data = self.tcga_data.mRNA.copy()
        mrna_data['Edited Patient ID'] = mrna_data['SAMPLE_ID'].apply(lambda x: '-'.join(x.split('-')[0:3])).to_list()
        mrna_data = mrna_data.set_index('Edited Patient ID')
        mrna_data = mrna_data.drop(['STUDY_ID', 'SAMPLE_ID'], axis = 1)
        #mrna_data = mrna_data.loc[[i for i in mrna_data.index if i in self.TCGA_data.survival.index]]
    

        #get high and low patients
        high = (mrna_data > self.tcga_data.cutoff)*1
        low = (mrna_data < -1*self.tcga_data.cutoff)*1


        #extract patients
        if type1 == 'high':
            patients_1 = high[high[protein1] == 1].index
        elif type1 == 'low':
            patients_1 = low[low[protein1] == 1].index
        else:
            raise ValueError('type must be high or low')
        
        if type2 == 'high':
            patients_2 = high[high[protein2] == 1].index
        elif type2 == 'low':
            patients_2 = low[low[protein2] == 1].index
        else:
            raise ValueError('type must be high or low')
        
        if colors is None:
            colors = np.repeat('black', 3)
        fig, ax = plt.subplots(figsize = (1.8, 2))
        
        group1_and_group2 = list(set(patients_1).intersection(patients_2))
        group1_only = list(set(patients_1).difference(patients_2))
        group2_only = list(set(patients_2).difference(patients_1)) 
        neither_group = list(set(mrna_data.index).difference(set(group1_and_group2 + group1_only + group2_only)))

        kmf = KaplanMeierFitter()
        plt_data1 = [self.tcga_data.survival[group1_and_group2], self.tcga_data.status[group1_and_group2]]
        kmf1 = kmf.fit(plt_data1[0].values, plt_data1[1].values, label = f'{protein1} {type1}, {protein2} {type2}')
        kmf1.plot(ax = ax, ci_show = False, linestyle = '-', color = colors[0])

        plt_data2 = [self.tcga_data.survival[group1_only], self.tcga_data.status[group1_only]]
        kmf2 = kmf.fit(plt_data2[0].values, plt_data2[1].values, label = f'{protein1} {type1} only')
        kmf2.plot(ax = ax, ci_show = False, linestyle = '--', color = colors[1])

        plt_data3 = [self.tcga_data.survival[group2_only], self.tcga_data.status[group2_only]]
        kmf3 = kmf.fit(plt_data3[0].values, plt_data3[1].values, label = f'{protein2} {type2} only')
        kmf3.plot(ax = ax, ci_show = False, linestyle =  ':', color = colors[2])



        # Customize the plot
        if title:
            ax.set_title(f'Kaplan-Meier Survival Curve: {protein1}-{type1}, {protein2}-{type2}')
        elif isinstance(title, str):
            ax.set_title(title)
            
        ax.set_xlabel('Survival\nMonths', fontsize = 9)
        #convert yticks to percentages
        ax.yaxis.set_major_formatter(mtick.PercentFormatter(1))
        ax.tick_params(labelsize = 7)

        plt.ylabel('Progression Free\nSurvival (%)', fontsize = 9)
        if leg_fontsize is None:
            leg_fontsize = 7
        
        if leg_loc is None:
            ax.legend(fontsize = leg_fontsize)
        else:
            ax.legend(fontsize = leg_fontsize, loc = leg_loc)

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/Figure5E_KM.svg', bbox_inches = 'tight', dpi = 300)


class SupplementaryFigure12:
    """
    Summary of identified PTMs impacted by ESRP1 mediated splicing
    """
    def __init__(self, TCGA_data):
        self.tcga_data = TCGA_data

    def PanelA(self, ax = None, panel_save_dir = None):
        if ax is None:
            fig, ax = plt.subplots(figsize = (3,2))

        #extract ptms with alterations and bin into high (included) and low (excluded)
        plt_data = self.tcga_data.sig_ptms.groupby('ESRP1_MW').size()
        plt_data = plt_data.rename({'High':'Included', 'Low':'Excluded'})
        #grab altered flanking sequences
        plt_data['Altered Flank'] = self.tcga_data.flanking_sequences['PTM'].nunique()
        ax.bar(plt_data.index, plt_data.values, color = 'gray')
        ax.set_ylabel('Number of PTMs', fontsize = 9)
        ax.tick_params(axis = 'x', labelsize = 9)
        if panel_save_dir is not None:
            plt.savefig(panel_save_dir + 'SFig12A_NumPTM.svg', bbox_inches = 'tight', dpi = 300)

    def PanelB(self, ax = None, panel_save_dir = None):
        if ax is None:
            fig,ax = plt.subplots(figsize = (3,3))

        exploded_sig = self.tcga_data.sig_ptms.copy()
        exploded_sig['Modification Class'] = exploded_sig['Modification Class'].apply(lambda x: x.split(';'))
        exploded_sig = exploded_sig.explode('Modification Class')
        plt_data = (exploded_sig.groupby('Modification Class').size()/exploded_sig.shape[0]).sort_values(ascending = False)

        #make pie chart, grouping all modifications with less than 5% of PTMs into 'Other
        plt_data = plt_data[plt_data > 0.05]
        plt_data['Other'] = 1 - plt_data.sum()
        plt_data = plt_data.sort_values(ascending = False)
        
        #construct pie chart
        ax.pie(plt_data, startangle = 90, counterclock = False)

        #make custom legend
        colors = sns.color_palette('tab10')
        patches = [mpatches.Patch(color = colors[i], label = plt_data.index[i]) for i in range(5)]
        ax.legend(handles = patches, loc = 'upper right', fontsize = 7, bbox_to_anchor = (1.4, 1))

        if panel_save_dir is not None:
            plt.savefig(panel_save_dir + 'SFig12B_PTMTypes.svg', bbox_inches = 'tight', dpi = 300)

    def PanelC(self, yang_data_dir, ax = None, panel_save_dir = None):
        yang = pd.read_csv(yang_data_dir + '/spliced_ptms_Yang2016.csv')
        yang_ptms = yang.apply(lambda x: x['UniProtKB Accession'] + '_' + x['Residue']+ str(int(float(x['PTM Position in Canonical Isoform']))) if x['PTM Position in Canonical Isoform'] == x['PTM Position in Canonical Isoform'] else x['Source of PTM'].split(';')[0], axis = 1)

        if ax is None:
            fig, ax = plt.subplots(figsize = (5,5))

        #grab ptm sets from prostate data and yang et al.
        data = [set(self.tcga_data.sig_ptms['PTM'].unique()), set(yang_ptms)]
        venn2(data, set_labels = ('Based on TCGA PRAD', 'ESRP1 Knockdown (Yang et al.)'))
        circles = venn2_circles(data)

        if panel_save_dir is not None:
            plt.savefig(panel_save_dir + 'SFig12C_Venn.svg', bbox_inches = 'tight', dpi = 300)

class SupplementaryFigure13:
    """
    Gene set enrichment analysis with EnrichR
    """
    def __init__(self, TCGA_data, pie_colors = None):
        self.tcga_data = TCGA_data
        self.pie_colors = self.tcga_data.pie_colors if pie_colors is None else pie_colors

    def create_figure(self, ax = None, save_dir = None):
        if not hasattr(self.tcga_data, 'enrichr'):
            self.tcga_data.process_enrichr()

        if ax is None:
            fig, ax = plt.subplots(figsize = (3,5))

        plt_data = self.tcga_data.enrichr[self.tcga_data.enrichr['Adjusted P-value'] <= 0.05]
        #remove inf combined score
        plt_data = plt_data[plt_data['Combined Score'] != np.inf]
        plot_EnrichR_pies(plt_data, ax = ax, colors = self.pie_colors, edgecolor = 'black', leg_loc = (0, 1.2))
        ax.tick_params(axis = 'y', labelsize = 9)

        if save_dir is not None:
            plt.savefig(save_dir + 'SupplementaryFigure13.pdf', bbox_inches = 'tight', dpi = 300)

class SupplementaryFigure14:
    """
    Functional associations for spliced and altered PTMs
    """
    def __init__(self, TCGA_data, bar_colors = None):
        self.tcga_data = TCGA_data
        self.bar_colors = self.tcga_data.bar_colors if bar_colors is None else bar_colors

    def PanelA(self, top_terms = 30, ax = None, save_panel_dir = None):
        if ax is None:
            fig, ax = plt.subplots(figsize = (2,3.5))

        self.tcga_data.plot_annotations(term_to_plot = 'EXONT:Name', colors = self.bar_colors, top_terms = top_terms, collapse_on_similar=False,legend = False,leg_loc = (0.2,1),ax = ax)
        ax.tick_params(axis = 'y', labelsize = 7)
        ax.set_ylim([-0.5, top_terms-0.5])

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig14A_EXONT.svg', bbox_inches = 'tight', dpi = 300)

    def PanelB(self, top_terms = 12, ax = None, save_panel_dir = None):
        if ax is None:
            fig, ax = plt.subplots(figsize = (1.6, 2))

        self.tcga_data.plot_annotations(term_to_plot = 'PSP:ON_PROCESS', colors = self.bar_colors, top_terms = top_terms, collapse_on_similar=True,legend = False,leg_loc = (0.2,1),ax = ax)
        ax.tick_params(axis = 'y', labelsize = 7)
        ax.set_ylim([-0.5, top_terms-0.5])

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig14B_PSPProcess.svg', bbox_inches = 'tight', dpi = 300)

    def PanelC(self, top_terms = 10, ax = None, save_panel_dir = None):
        if ax is None:
            fig, ax = plt.subplots(figsize = (1.6, 2))
            
        self.tcga_data.plot_annotations(term_to_plot = 'PSP:ON_FUNCTION', colors = self.bar_colors, top_terms = top_terms, collapse_on_similar=True,legend = False,leg_loc = (0.2,1),ax = ax)
        ax.tick_params(axis = 'y', labelsize = 7)
        ax.set_ylim([-0.5, top_terms-0.5])

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig14B_PSPFunction.svg', bbox_inches = 'tight', dpi = 300)

class SupplementaryFigure15:
    """
    PTM-associated interaction properties
    """
    def __init__(self, TCGA_data, bar_colors = None):
        self.tcga_data = TCGA_data
        self.bar_colors = self.tcga_data.bar_colors if bar_colors is None else bar_colors

        if not hasattr(self.tcga_data, 'network_stats'):
            self.tcga_data.network_stats = pd.read_csv(self.tcga_data.analysis_dir + '/TCGA/PTM_Network_Properties.csv', index_col = 0)

    def PanelA(self, ax = None, save_panel_dir = None):
        if ax is None:
            fig, ax = plt.subplots(figsize = (2,3.5))

        plt_data = self.tcga_data.network_stats['Degree Centrality'].sort_values(ascending = True)
        plt_data = plt_data[plt_data > 0.015]

        ax.barh(plt_data.index, plt_data, color = self.tcga_data.pie_colors[1], edgecolor = 'black')
        ax.tick_params(labelsize = 8)
        ax.set_ylim([-0.6, plt_data.shape[0] - 0.4])
        ax.set_xlabel('Degree Centrality', fontsize = 9)

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig15A_DegreeCentrality.svg', bbox_inches = 'tight', dpi = 300)

    def PanelB(self, ax = None, save_panel_dir = None):
        plt_data = self.tcga_data.network_stats['Betweenness'].sort_values(ascending = True)
        plt_data = plt_data[plt_data > 0.015]
        if ax is None:
            fig, ax = plt.subplots(figsize = (2, 3.5))

        ax.barh(plt_data.index, plt_data, color = self.tcga_data.pie_colors[1], edgecolor = 'black')
        ax.tick_params(labelsize = 8)
        ax.set_ylim([-0.6, plt_data.shape[0] - 0.4])
        ax.set_xlabel('Betweenness Centrality', fontsize = 9)
        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig15B_Betweenness.svg', bbox_inches = 'tight', dpi = 300)

    def draw_network(self, protein_subset = None, in_domain_color = 'darkorange', out_domain_color = 'darkorange', in_domain_marker = 'X', out_domain_marker = 'o', interacting_color = 'gray', modified_only = True, small_marker = 3, large_marker = 20, with_labels = 'All', small_labelsize = 4, large_labelsize = 6, seed = 200, ax = None):
        """
        Given a protein subset, plot the subnetwork of interactions associated with those proteins

        Parameters:
        -----------
        protein_subset: list
            List of proteins to include in the network
        in_domain_color: str
            color of nodes which have interacting ptms in a domain
        out_domain_color: str
            color of nodes which have interacting ptms out of a domain
        in_domain_marker: str
            marker of nodes which have interacting ptms in a domain 
        out_domain_marker: str
            marker of nodes which have interacting ptms out of a domain
        interacting_color: str
            color of nodes which are interacting with spliced ptms but are not themselves spliced
        modified_only: bool
            only include nodes which have been modified by splicing when deciding which interactions to keep
        small_marker: int
            size of nodes that are not spliced
        large_marker: int
            size of nodes that are spliced
        with_labels: str
            'All' - include all labels, 'Modified' - only include labels for modified nodes
        small_labelsize: int
            size of labels for nodes that are not spliced
        large_labelsize: int
            size of labels for nodes that are spliced
        seed: int
            seed for network layout
        ax: matplotlib axis
            axis to plot network on

        """
        if not hasattr(self.tcga_data, 'interactions'):
            self.tcga_data.interactions = pd.read_csv(self.tcga_data.analysis_dir + '/TCGA/PTM_interactions.csv')
            self.tcga_data.interactions['Regulation Change'] = self.tcga_data.interactions.apply(lambda x: 1 if x['Type'] != 'DISRUPTS' and x['deltaPSI_MW'] > 0 else 1 if x['Type'] == 'DISRUPTS' and x['deltaPSI_MW'] < 0 else -1, axis = 1)

        
        #set node colors
        network_data = self.tcga_data.interactions.drop_duplicates()
        network_data = network_data.dropna(subset = 'deltaPSI_MW')
        if protein_subset is not None:
            if modified_only:
                network_data = network_data[(network_data['Modified Gene'].isin(protein_subset))]
            else:
                network_data = network_data[(network_data['Modified Gene'].isin(protein_subset)) | (network_data['Modified Gene'].isin(protein_subset))]
        
        G = nx.from_pandas_edgelist(network_data, source = 'Modified Gene', target = 'Interacting Gene')

        in_domain_data = network_data[network_data['In Domain'] == 1].copy()


        #color nodes based on whether ptm is modified Gene (Gene column) and is significantly controlled by splicing
        node_colors = []
        node_sizes = []
        marker_type = []
        in_domain_prots = []
        out_domain_prots = []
        for node in G.nodes:
            if node in in_domain_data['Modified Gene'].unique():
                node_colors.append(in_domain_color)
                marker_type.append(in_domain_marker)
                in_domain_prots.append(node)
            elif node in network_data['Modified Gene'].unique():
                node_colors.append(out_domain_color)
                marker_type.append(out_domain_marker)
                out_domain_prots.append(node)
            else:
                node_colors.append(interacting_color)
                marker_type.append(out_domain_marker)

        #adjust line style of edge depending on sign of deltaPSI_MW
        edge_style = []
        for edge in G.edges:
            edge_data = network_data[((network_data['Modified Gene'] == edge[0]) & (network_data['Interacting Gene'] == edge[1])) | ((network_data['Modified Gene'] == edge[1]) & (network_data['Interacting Gene'] == edge[0]))]
            if edge_data['Regulation Change'].values[0] == 1:
                edge_style.append('solid')
            else:
                edge_style.append('dotted')

        if ax is None:
            fig, ax = plt.subplots(figsize = (3,3))

        np.random.seed(seed)
        G.pos = nx.spring_layout(G, seed = seed)

        nx.draw(G, node_size = 3, style = edge_style, width = 0.5,font_size = 6,node_color = interacting_color, edge_color = 'gray', ax = ax)
        nx.draw_networkx_nodes(G, pos = G.pos, nodelist = in_domain_prots, edgecolors = 'black',linewidths = 0.2,node_shape = in_domain_marker, node_color =in_domain_color, node_size = 20, ax = ax)
        nx.draw_networkx_labels(G, pos = G.pos, labels = {n:n for n in G.nodes() if n in in_domain_prots},ax = ax, font_size = 6, horizontalalignment = 
        'right')
        nx.draw_networkx_nodes(G, pos = G.pos, nodelist = out_domain_prots, edgecolors = 'black', linewidths = 0.2, node_shape = out_domain_marker, node_color = out_domain_color, node_size = 20, ax = ax)

        if with_labels == "Modified" or with_labels == 'All':
            nx.draw_networkx_labels(G, pos = G.pos, labels = {n:n for n in G.nodes() if n in in_domain_prots or n in out_domain_prots},ax = ax, font_size = large_labelsize, horizontalalignment = 'right', font_weight = 'bold')

        if with_labels == 'All':
            nx.draw_networkx_labels(G, pos = G.pos, labels = {n:n for n in G.nodes() if n not in out_domain_prots and n not in in_domain_prots},ax = ax, font_size = small_labelsize, horizontalalignment = 'right')

    def PanelC(self, ax = None, save_panel_dir = None):
        if ax is None:
            fig, ax = plt.subplots(figsize = (5,5))

        protein_subset = ['CRK','ABI1','SRC','ABL1', 'TRIP6','CTNND1']
        self.draw_network(protein_subset = protein_subset, modified_only = False, small_labelsize = 6, large_labelsize = 9, ax = ax)

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig15C_SRC.svg', bbox_inches = 'tight', dpi = 300)

    def PanelD(self, ax = None, save_panel_dir = None):
        if ax is None:
            fig, ax = plt.subplots(figsize = (5,5))

        protein_subset = protein_subset = [gene for gene in self.tcga_data.interactions['Modified Gene'].unique() if (gene.startswith('RPS') or gene.startswith('RPL')) and not gene.startswith('RPS6')]
        self.draw_network(protein_subset = protein_subset, small_labelsize = 7, large_labelsize = 9, ax = ax)

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig15D_RiboNetwork.svg', bbox_inches = 'tight', dpi = 300)

class SupplementaryFigure16:
    """
    Impact of altered flanking sequences in TCGA data
    """
    def __init__(self, TCGA_data, bar_color = None):
        self.tcga_data = TCGA_data
        self.bar_color = self.tcga_data.bar_colors[2] if bar_color is None else bar_color

    def PanelA(self, ax = None, save_panel_dir = None):
        if ax is None:
            fig, ax = plt.subplots(figsize = (2,2))

        exploded_mod_flanks = self.tcga_data.flanking_sequences.copy()
        exploded_mod_flanks['Modification Class'] = exploded_mod_flanks['Modification Class'].apply(lambda x: x.split(';'))
        exploded_mod_flanks = exploded_mod_flanks.explode('Modification Class')
        plt_data = exploded_mod_flanks.groupby('Modification Class').size().sort_values()


        ax.barh(plt_data.index, plt_data.values, color = self.bar_color)
        #plt.xticks(rotation = 35, ha = 'right', fontsize = 8)
        ax.tick_params(labelsize = 8)
        ax.set_xlabel('Number of PTMs with\nChanged Flanking Sequence', fontsize = 8)

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig16A_NumPTMFlank.svg', bbox_inches = 'tight', dpi = 300)

    def PanelB(self, ax = None, save_panel_dir = None):
        if ax is None:
            fig, ax = plt.subplots(figsize = (2.5,1))

        ax.hist(self.tcga_data.flanking_sequences['Similarity'], bins = 5, color = self.bar_color)
        ax.set_xlabel('Sequence Identity Between\nInclusion and Exclusion Sequences', fontsize = 9)
        ax.set_ylabel('Number\nof PTMs', fontsize = 9)
        ax.set_xlim([0,1])
        ax.set_xticks([0,0.25,0.5,0.75,1])
        ax.set_yticks([0,25,50,75,100])
        ax.tick_params(labelsize = 8)

        #convert x axis to percents
        ax.xaxis.set_major_formatter(mtick.PercentFormatter(1))

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig16B_FlankSeqIdentity.svg', bbox_inches = 'tight', dpi = 300)

    def PanelC(self, ax = None, save_panel_dir = None):
        if ax is None:
            fig, ax = plt.subplots(figsize = (2.5,1))

        flank_data = self.tcga_data.flanking_sequences.dropna(subset = 'Location of Altered Flank').copy()

        position_breakdown = flank_data.copy()
        position_breakdown['Altered_Positions'] = position_breakdown['Altered_Positions'].str.split(';')
        position_breakdown['Residue Changes'] = position_breakdown['Residue Changes'].str.split(';')
        position_breakdown = position_breakdown.explode(['Altered_Positions', 'Residue Changes']).copy()[['Gene', 'PTM','Altered_Positions', 'Residue Changes']]
        position_breakdown['Altered_Positions'] = position_breakdown['Altered_Positions'].astype(int)
        plt_data = position_breakdown.groupby('Altered_Positions').size()
        ax.bar(plt_data.index, plt_data.values, color = self.bar_color)
        ax.set_xlim([-5.5,5.5])
        ax.set_xlabel('Position Relative to PTM', fontsize = 9)
        ax.set_ylabel('Number of\nChanged\nResidues', fontsize = 9)
        ticks = ax.set_xticks(np.arange(-5,6,1))
        ax.tick_params(labelsize = 8)

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + 'SFig16C_AlteredPositions.svg', bbox_inches = 'tight', dpi = 300)

    def PanelD(self, elm_data_file = None, ax = None, save_panel_dir = None):
        if not hasattr(self, 'elm'):
            self.elm = pd.read_csv(elm_data_file, sep = '\t', header = 5)
        unique_motifs = self.elm['ELMIdentifier'].unique()


        motif_data = self.tcga_data.flanking_sequences.dropna(subset = ['Motif only in Inclusion', 'Motif only in Exclusion'])
        
        if not hasattr(self, 'num_motifs'):
            num_motifs = {}
            for motif in unique_motifs:
                num_motifs[motif] = 0
                for i,row in motif_data.iterrows():
                    if motif in row['Motif only in Inclusion']:
                        num_motifs[motif] += 1
                    if motif in row['Motif only in Exclusion']:
                        num_motifs[motif] += 1
            self.num_motifs = num_motifs

        if ax is None:
            fig, ax = plt.subplots(figsize = (2,3.5))

        num_motifs = pd.Series(self.num_motifs)
        lig_motifs = num_motifs[num_motifs.index.str.contains("LIG")]
        lig_motifs = lig_motifs[lig_motifs > 1]
        lig_motifs = lig_motifs.sort_values()
        #get rid of '_' in index
        lig_motifs.index = lig_motifs.index.str.replace('_',' ')
        ax.barh(lig_motifs.index, lig_motifs.values, color = self.bar_color)
        #ticks = plt.xticks(rotation = 90, fontsize = 8)
        ax.set_xlabel('Number of PTMs in\nDisrupted Motif', fontsize = 9)
        #ax.set_ylabel('ELM Motif Class', fontsize = 9)
        ax.text(-0.5, len(lig_motifs), 'ELM Motif Class', ha = 'right', weight = 'bold', fontsize = 9)
        ax.tick_params(labelsize = 7)
        ax.set_ylim([-0.5, len(lig_motifs)-0.5])

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig16D_DisruptedMotifs.svg', bbox_inches = 'tight', dpi = 300)

    def PanelE(self, save_panel_dir = None):
        if not hasattr(self, 'domain'):
            domain_name = 'LIG_14-3-3_CanoR_1'
            motif_data = self.tcga_data.flanking_sequences.dropna(subset = ['Inclusion Flanking Sequence', 'Exclusion Flanking Sequence'], how = 'all')
            motif_data = motif_data[['Gene', 'Region ID', 'PTM', 'Modification Class', 'Inclusion Flanking Sequence', 'Exclusion Flanking Sequence', 'deltaPSI_MW','Motif in Both', 'Motif only in Inclusion', 'Motif only in Exclusion']]
            domain = motif_data.copy()
            for i, row in domain.iterrows():
                if row['Motif only in Inclusion'] == row['Motif only in Inclusion']:
                    if domain_name in row['Motif only in Inclusion']:
                        domain.loc[i, 'Motif only in Inclusion'] = ';'.join([motif for motif in row['Motif only in Inclusion'].split(';') if domain_name in motif])
                    else:
                        domain.loc[i, 'Motif only in Inclusion'] = np.nan

                if row['Motif only in Exclusion'] == row['Motif only in Exclusion']:
                    if domain_name in row['Motif only in Exclusion']:
                        domain.loc[i, 'Motif only in Exclusion'] = ';'.join([motif for motif in row['Motif only in Exclusion'].split(';') if domain_name in motif])
                    else:
                        domain.loc[i, 'Motif only in Exclusion'] = np.nan

            domain = domain.dropna(subset = ['Motif only in Inclusion', 'Motif only in Exclusion'], how = 'all')
            domain = domain[domain['Modification Class'].str.contains('Phosphorylation')]
            domain = domain[(domain['PTM'].str.contains('_S')) | (domain['PTM'].str.contains('_T'))]

        flank_data = self.tcga_data.flanking_sequences[self.tcga_data.flanking_sequences['Modification Class'].str.contains('Phosphorylation')].copy()
        flank_data = flank_data[(flank_data['PTM'].isin(domain['PTM'])) & (flank_data['Region ID'].isin(domain['Region ID'])) & (flank_data['Exclusion Flanking Sequence'].isin(domain['Exclusion Flanking Sequence']))]
        position_breakdown = flank_data.copy()
        position_breakdown['Altered_Positions'] = position_breakdown['Altered_Positions'].str.split(';')
        position_breakdown['Residue Changes'] = position_breakdown['Residue Changes'].str.split(';')
        position_breakdown = position_breakdown.explode(['Altered_Positions', 'Residue Changes']).copy()[['Gene', 'PTM','Altered_Positions', 'Residue Changes']]
        position_breakdown['Altered_Positions'] = position_breakdown['Altered_Positions'].astype(int)
        position_breakdown = position_breakdown.drop_duplicates()
        position_breakdown = position_breakdown[position_breakdown['Gene'] != 'ARMC6']
        plt_data = position_breakdown.groupby('Altered_Positions').size().sort_values(ascending = False).drop_duplicates()

        #position_breakdown = position_breakdown.drop_duplicates(subset = ["PTM", "Altered_Positions"], keep = False)
        position_matrix = position_breakdown.pivot(columns = 'Altered_Positions', index = 'PTM', values= 'Residue Changes')
        for i, pos in zip(range(11),range(-5, 6)):
            if pos not in position_matrix.columns:
                position_matrix.insert(i, pos, np.nan)

        #convert ptm to gene name from uniprot
        position_matrix.index = [POSE_config.uniprot_to_gene[ptm.split('_')[0]].split(' ')[0]+ ' ' + ptm.split('_')[1] for ptm in position_matrix.index]
        #replace strings with 1 and nans with 0
        position_values = position_matrix.applymap(lambda x: 1 if x == x else np.nan).sort_values(by = 5)
        position_matrix = position_matrix.loc[position_values.index]
        #plot heatmap with black edges around cells and no colorbar, annotate with strings in position matrix
        fig, ax = plt.subplots(figsize = (3.5,2.5))
        sns.heatmap(position_values, cmap = 'Greens', vmin = 0, vmax = 2, ax = ax, cbar = False, linewidths = 0.5, linecolor = 'black', yticklabels=True )
        ax.set_facecolor("lightgrey")
        for i in range(position_values.shape[0]):
            for j in range(position_values.shape[1]):
                if position_values.iloc[i,j] == 1:
                    ax.text(j+0.5, i+0.5, position_matrix.iloc[i,j], ha = 'center', va = 'center', fontsize = 6)
        ax.set_xticklabels(['-5','-4','-3','-2','-1','pS/pT','1','2','3','4','5'], fontsize = 8)
        ax.set_xlabel('')
        ax.tick_params(axis = 'y', labelsize = 8)
        ax.set_title('Disrupted Canonical 14-3-3 Binding Motif', fontsize = 9)
        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig16E_14-3-3.svg', bbox_inches = 'tight', dpi = 300)

class SupplementaryFigure17:
    """
    Kinases most impacted by ESRP1 splicing
    """
    def __init__(self, TCGA_data, bar_colors = None):
        self.tcga_data = TCGA_data
        self.bar_colors = self.tcga_data.bar_colors if bar_colors is None else bar_colors

    def PanelA(self, top_terms = 30, ax = None, save_panel_dir = None):
        if ax is None:
            fig, ax = plt.subplots(figsize = (2,3.5))


        self.tcga_data.plot_annotations(legend = False, term_to_plot = 'Combined:Kinase', colors = self.bar_colors, top_terms = top_terms, collapse_on_similar=False,leg_loc = (0.2,1),ax = ax)
        ax.tick_params(axis = 'y', labelsize = 8)
        ax.tick_params(axis = 'x', labelsize = 9)
        ax.set_xlabel('Number of Substrates', fontsize = 10)
        ax.set_ylim([-0.5, top_terms-0.5])

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig17A_KnownKS.svg', bbox_inches = 'tight', dpi = 300)

    def PanelA_legend(self, save_panel_dir = None):
        fig, ax = plt.subplots(figsize = (1,1))
        handles = [mpatches.Patch(facecolor = self.bar_colors[0], edgecolor = 'black', label = 'Excluded'), mpatches.Patch(facecolor = self.bar_colors[1], edgecolor = 'black', label = 'Included'),mpatches.Patch(facecolor = self.bar_colors[2], edgecolor = 'black', label = 'Altered Flank')]
        ax.legend(handles = handles, ncol = 2, loc = 'center', fontsize = 8, title = 'Type of Impact', title_fontsize = 9)
        ax.axis('off')

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig17A_Legend.svg', bbox_inches = 'tight', dpi = 300)

    def PanelB(self, save_panel_dir = None):
        if not hasattr(self.tcga_data, 'kstar_results'):  
            self.tcga_data.process_kinase_activities()    

        from kstar import plot
        plt_data = self.tcga_data.kstar_results[['High', 'Low']]
        #add in 0 for missing kinases
        plt_data = plt_data.rename({'High':'Enrichment\nAmong\nIncluded\nPTMs', 'Low':'Enrichment\nAmong\nExcluded\nPTMs'}, axis = 1)

        plt_data = plt_data.replace(np.nan, 1)
        fig, ax = plt.subplots(ncols = 2, figsize = (2.5, 4), width_ratios = [0.1,1], sharey = True)
        fig.subplots_adjust(wspace = 0)
        plt_data.replace()
        dots = plot.DotPlot(-np.log10(plt_data), plt_data, figsize = (1.5,4),  colormap = {0: '#6b838f', 1: self.tcga_data.pie_colors[1]})
        dots.drop_kinases_with_no_significance()
        dots.cluster(orientation = 'left', ax = ax[0], method='ward')
        ax[0].set_xticks([])
        dots.dotplot(color_legend = False, size_legend = False, ax = ax[1])
        ax[1].tick_params(axis = 'x', rotation = 0, labelsize = 9)

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig17B_KSTAR.svg', bbox_inches = 'tight', dpi = 300)
    def PanelB_Legend(self, save_panel_dir = None):
        fig, ax = plt.subplots(figsize = (1,1))
        handles = [Line2D([0], [0], marker='o', markerfacecolor = self.tcga_data.pie_colors[1], color='w', label='Significant', markersize=10), Line2D([0], [0], marker='o',markerfacecolor='#6b838f', color='w', label='Not Enriched', markersize=5)]
        ax.legend(handles = handles, ncol = 2, loc = 'center', fontsize = 9, title = 'KSTAR Enrichment', title_fontsize = 10)
        ax.axis('off')

        if save_panel_dir is not None:
            plt.savefig(save_panel_dir + '/SFig17B_Legend.svg', bbox_inches = 'tight', dpi = 300)


    def PanelC(self, save_panel_dir = None):
        from kstar.analysis import interactions
        import pickle
        from kstar import config

        ks_dataset = pd.read_csv(self.tcga_data.database_dir + '/PhosphoSitePlus/Kinase_Substrate_Dataset.gz', sep = '\t', header = 2, on_bad_lines='skip',compression = 'gzip', encoding = "cp1252")
        #restrict to human data
        ks_dataset = ks_dataset[ks_dataset['KIN_ORGANISM'] == 'human']
        ks_dataset = ks_dataset[ks_dataset['SUB_ORGANISM'] == 'human']
        ks_dataset['PTM'] = ks_dataset['SUB_ACC_ID'] + '_' + ks_dataset['SUB_MOD_RSD']

        #load KSTAR networks and KS data
        networks = {}
        networks['Y'] =pickle.load(open(config.NETWORK_Y_PICKLE, "rb" ) )
        networks['ST'] = pickle.load(open(config.NETWORK_ST_PICKLE, "rb" ) )

        #get PTMs included with ESRP1
        high_sig = self.tcga_data.sig_ptms[self.tcga_data.sig_ptms['ESRP1_MW'] == 'High'].copy()
        high_sig = high_sig[(high_sig['Modification'].str.contains('Phosphoserine')) | (high_sig["Modification"].str.contains('Phosphothreonine'))]
        high_sig['data:sig_ptms'] = 1
        high_sig.rename({'PTM':'KSTAR_SUBSTRATE'},  axis = 1, inplace = True)
        high_sig['KSTAR_SITE'] = high_sig['KSTAR_SUBSTRATE'].apply(lambda x: x.split('_')[1])
        high_sig['KSTAR_ACCESSION'] = high_sig['KSTAR_SUBSTRATE'].apply(lambda x: x.split('_')[0])

        #get substrate influence on prediction
        kinase = 'SGK1'
        experiment_influence = interactions.getSubstrateInfluence_inExperiment(networks['ST'], high_sig, kinase)

        #process and annotate known substrates
        known_kin = ks_dataset[ks_dataset['GENE'] == kinase]
        sub_data = experiment_influence['data:sig_ptms'].reset_index()
        sub_data['UniProt_ID'] = sub_data['index'].apply(lambda x: x.split('_')[0])
        sub_data['Site'] = sub_data['index'].apply(lambda x: x.split('_')[1])
        sub_data = sub_data.merge(known_kin['PTM'], left_on = ['index'], right_on = ['PTM'], how = 'left')
        sub_data["Known"] = sub_data["PTM"].apply(lambda x: 0 if pd.isnull(x) else 1)
        sub_data = sub_data.drop('PTM', axis = 1)

        #add gene names
        from ExonPTMapper import config as mapper_config
        sub_data = sub_data.drop_duplicates()
        sub_data = sub_data.merge(mapper_config.translator[['UniProtKB/Swiss-Prot ID','Gene name']], left_on = 'UniProt_ID', right_on = 'UniProtKB/Swiss-Prot ID', how = 'left')
        sub_data = sub_data.drop_duplicates()

        #process
        nice_data = sub_data[sub_data['Number of Networks connected to SGK1'] >= 3].copy()
        nice_data['Site Number'] = nice_data['Site'].apply(lambda x: x[1:])
        nice_data = nice_data.sort_values(by  = ['Gene name', 'Site Number'])
        nice_data = nice_data[['Gene name','Site','Known']]
        nice_data = nice_data.groupby('Gene name')['Site'].agg(', '.join).reset_index()

        if save_panel_dir is not None:
            nice_data.to_csv(save_panel_dir + '/SFig17C_KnownSubstrates.csv', index = False)




class SupplementaryTable3:
    """
    Tables of PTMs regulated by ESRP1
    """
    def __init__(self, data):
        #point to figure data class
        self.data = data
        self.process_data()



    def process_data(self):
        #extract ptm table, residue and modification information
        stable3 = self.data.sig_ptms.copy()

        #grab high and low patients and calculate median psi for each group
        stable3['Median PSI (ESRP1 High)'] = stable3[[pat for pat in self.data.ESRP1_high if pat in stable3.columns]].median(axis = 1)
        stable3['Median PSI (ESRP1 Low)'] = stable3[[pat for pat in self.data.ESRP1_low if pat in stable3.columns]].median(axis = 1)

        #extract only certain columns and rename
        stable3 = stable3[['Gene','Individual exon','Residue','PTM Position in Canonical Isoform', 'Modification', 'Median PSI (ESRP1 Low)', 'Median PSI (ESRP1 High)', 'p-adj_MW', 'Effect Size_MW']]
        stable3 = stable3.rename({'Individual exon':'Exon', 'ESRP1':'Group with Higher PSI', 'p-adj_MW': 'Adjusted p-value', 'Effect Size_MW':'Effect Size'}, axis = 1)
        self.table = stable3
    
    def create_low_table(self):
        """
        Extract prostate ptms that are included at a higher rate in the ESRP1 low group
        """
        low_table = self.table[self.table['Median PSI (ESRP1 Low)'] > self.table['Median PSI (ESRP1 High)']].copy()
        return low_table
    
    def create_high_table(self):
        """
        Extract prostate ptms that are included at a higher rate in the ESRP1 high group
        """
        high_table = self.table[self.table['Median PSI (ESRP1 Low)'] > self.table['Median PSI (ESRP1 High)']].copy()
        return high_table

    def create_flank_table(self):
        from_flank_table = self.data.flanking_sequences[self.data.flanking_sequences['Which Flank'] == 'First']
        from_flank_table = from_flank_table[(~from_flank_table['Matched']) & (~from_flank_table['Stop Codon Introduced'])]
        from_flank_table = from_flank_table[['Gene','from_exon','exons', 'PTM','Residue', 'Modification Class', 'deltaPSI_MW', 'p-adj_MW','Effect Size_MW', 'Inclusion Flanking Sequence', 'Exclusion Flanking Sequence', 'Similarity', 'Motif only in Inclusion', "Motif only in Exclusion"]]
        from_flank_table = from_flank_table.rename(columns = {'PTM':'Protein', 'from_exon':'PTM-containing Exon', 'exons':'Spliced exon(s)', 'deltaPSI_MW':'Change in PSI (High - Low)', 'p-adj_MW':'Adjusted p-value', 'Effect Size_MW':'Effect Size', 'Motif only in Inclusion':'ELM Motif Class matched only to Inclusion Sequence', 'Motif only in Exclusion':'ELM Motif Class matched only to Exclusion Sequence'})
        from_flank_table['Residue'] = from_flank_table['Protein'].apply(lambda x: x.split('_')[1])
        from_flank_table['Protein'] = from_flank_table['Protein'].apply(lambda x: x.split('_')[0])

        to_flank_table = self.data.flanking_sequences[self.data.flanking_sequences['Which Flank'] == 'Second']
        to_flank_table = to_flank_table[(~to_flank_table['Matched']) & (~to_flank_table['Stop Codon Introduced'])]
        to_flank_table = to_flank_table[['Gene','to_exon','exons', 'PTM', 'Residue', 'Modification Class', 'deltaPSI_MW', 'p-adj_MW','Effect Size_MW', 'Inclusion Flanking Sequence', 'Exclusion Flanking Sequence', 'Similarity', 'Motif only in Inclusion', "Motif only in Exclusion"]]
        to_flank_table = to_flank_table.rename(columns = {'PTM':'Protein', 'to_exon':'PTM-containing Exon', 'exons':'Spliced exon(s)', 'deltaPSI_MW':'Change in PSI (High - Low)', 'p-adj_MW':'Adjusted p-value', 'Effect Size_MW':'Effect Size', 'Motif only in Inclusion':'ELM Motif Class matched only to Inclusion Sequence', 'Motif only in Exclusion':'ELM Motif Class matched only to Exclusion Sequence'})
        to_flank_table['Residue'] = to_flank_table['Protein'].apply(lambda x: x.split('_')[1])
        to_flank_table['Protein'] = to_flank_table['Protein'].apply(lambda x: x.split('_')[0])

        flank_table = pd.concat([from_flank_table, to_flank_table])
        return flank_table

    

    
    def create_worksheet(self, save_dir = None):
        if save_dir is None:
            save_dir = self.data.table_save_dir
        else:
            save_dir = save_dir

        low_table = self.create_low_table()
        high_table = self.create_high_table()
        flank_table = self.create_flank_table()

        #save each table to a different sheet of the same excel file
        writer = pd.ExcelWriter(save_dir + 'SupplementaryTable3.xlsx', engine='openpyxl')
        low_table.to_excel(writer, sheet_name='ESRP1-Low Included PTMs', index = False)
        high_table.to_excel(writer, sheet_name='ESRP1-High Included PTMs', index = False)
        flank_table.to_excel(writer, sheet_name='Altered Flanking Sequences', index = False)

        writer.close()
     

def range_normalize(x, min_val, max_val, desired_range = [0,1]):
    """
    Normalize a value to a desired range

    Parameters
    ----------
    x : float
        value to normalize
    min_val : float
        minimum value of range to normalize to
    max_val : float
        maximum value of range to normalize to
    desired_range : list, optional
        desired range to normalize to. The default is [0,1].

    Returns
    -------
    float
        normalized value

    """
    return (x-min_val)/(max_val-min_val)*(desired_range[1]-desired_range[0])+desired_range[0]
        



def draw_pie(dist, xpos, ypos, size,colors,edgecolor =None, type = 'donut', ax=None):
    """
    Draws pies individually, as if points on a scatter plot. This function was taken from this stack overflow post: https://stackoverflow.com/questions/56337732/how-to-plot-scatter-pie-chart-using-matplotlib
    
    Parameters
    ----------
    dist: list
        list of values to be represented as pie slices for a single point
    xpos: float
        x position of pie chart in the scatter plot
    ypos: float
        y position of pie chart in the scatter plot
    size: float
        size of pie chart
    colors: list
        list of colors to use for pie slices
    ax: matplotlib.Axes
        axis to plot on, if None, will create new figure
    """
    if ax is None:
        fig, ax = plt.subplots(figsize=(10,8))
    #remove slices with 0 size
    colors = [c for c, d in zip(colors, dist) if d != 0]
    dist = [d for d in dist if d != 0]
    # for incremental pie slices
    cumsum = np.cumsum(dist)
    cumsum = cumsum/ cumsum[-1]
    pie = [0] + cumsum.tolist()

    num_colors = len(dist)
    for i, r1, r2 in zip(range(num_colors), pie[:-1], pie[1:]):
        angles = np.linspace(2 * np.pi * r1, 2 * np.pi * r2)
        x = [0] + np.cos(angles).tolist()
        y = [0] + np.sin(angles).tolist()

        xy = np.column_stack([x, y])

        ax.scatter([xpos], [ypos], marker=xy, s=size, facecolor= colors[i], edgecolors=edgecolor, linewidth = 0.3)

        if type == 'donut': # add white circle in the middle
            donut_edgecolors = 'w' if edgecolor is None else edgecolor
            ax.scatter([xpos], [ypos], s=size/5, facecolor='w', edgecolors=donut_edgecolors, linewidth = 0.3)
    return ax


def half_pie_plot(sizes, ax, label_percents = False, total_for_percent = None, radius = 0.8, percent_offset = 0.8, wedge_width = 0.5, palette = sns.color_palette('colorblind'), percent_size = 6):
    """
    Given a list of sizes of a given group, plot a half pie chart with the provided sizes (bottom half will be blank slice)
    
    Parameters
    ----------
    sizes: list
        sizes of each group to plot
    ax: matplotlib.Axes
        axis to plot on
    label_percents: bool
        whether to label each pie slice with the percent belonging to that group
    total_for_percent: int
        total number of items to calculate percent from, if None, will use sum of sizes
    radius: float
        radius of pie chart
    percent_offset: float
        offset of percent labels from center of pie chart
    wedge_width: float
        width of the wedge to use for the pie
    palette: list
        list of colors to use for pie slices
    percent_size: int
        fontsize of percent labels
    
    """
    #add blank space to obscure bottom of pie
    sizes.append(sum(sizes))  # 50% blank
    ax.pie(sizes, autopct='', colors = palette, startangle=0, radius = radius, wedgeprops=dict(width=wedge_width))


    # Calculate percentages and add labels
    if label_percents:
        if total_for_percent is None:
            total_for_percent = sum(sizes)
        total = sum(sizes)
        cumulative_sizes = np.cumsum(sizes)
        for i, size in enumerate(sizes):
            if i != len(sizes)-1:
                theta = 2 * np.pi * ((cumulative_sizes[i] - size/2) / total)  # angle of the pie slice
                r = radius*percent_offset
                pct = (size/total_for_percent)*100
                x = r * np.cos(theta)
                y = r * np.sin(theta)
                rotation = np.degrees(theta) - 90
                ax.text(x, y,  f'{pct:.1f}%', rotation = rotation, ha='center', va = 'center', fontsize = percent_size)


def plot_EnrichR_pies(enrichr_results, terms_to_plot = None, colors = None, edgecolor = None, xlim = [0,200], leg_loc = (0,2), type = 'circle', ax = None):
    """
    Given PTM-specific EnrichR results, plot EnrichR score for the provided terms, with each self point represented as a pie chart indicating the fraction of genes in the group with PTMs
    
    Parameters
    ----------
    ptm_results: pd.selfFrame
        selfFrame containing PTM-specific results from EnrichR analysis
    terms_to_plot: list
        list of terms to plot
    ax: matplotlib.Axes
        axis to plot on, if None, will create new figure
    """
    if colors is None:
        colors = sns.color_palette('colorblind', n_colors = 3)

    plt_data = enrichr_results.dropna(subset = ['Number of No PTM Genes', 'Number of With Altered PTM Genes', 'Number of With Spliced PTM Genes']).copy()
    if terms_to_plot is None:
        plt_data = plt_data.sort_values(by = 'Fraction With PTMs')
    else:
        plt_data = plt_data[plt_data['Term'].isin(terms_to_plot)].sort_values(by = 'Fraction With PTMs')
    
    #remove gene ontology specific terms
    plt_data['Term'] = plt_data['Term'].apply(lambda x: x.split(' R-HSA')[0] +' (R)' if 'R-HSA' in x else x.split('(GO')[0]+' (GO)')
    #construct multiple piecharts for each term in 'Term' column, where location along x-axis is dictated by combined score and piechart is dictated by 'Fraction With PTMs'
    plt_data = plt_data.reset_index(drop = True)
    if ax is None:
        fig, ax = plt.subplots(figsize = (2, 1))

    ax.set_xlim(xlim)
    mult = 4
    ax.set_yticks(list(range(0,plt_data.shape[0]*mult,mult)))
    ax.set_yticklabels(plt_data['Term'].values)
    ax.set_ylim([-(mult/2), plt_data.shape[0]*mult-(mult/2)])
    for i, row in plt_data.iterrows():
        draw_pie([row['Number of With Altered PTM Genes'], row['Number of With Spliced PTM Genes'], row['Number of No PTM Genes']],xpos = row['Combined Score'], ypos = i*mult, colors = colors, edgecolor=edgecolor,ax = ax, type = type, size = 70)
        ax.axhline(i*mult+(mult/2), c= 'k', lw = 0.5)
        ax.axhline(i*mult-(mult/2), c = 'k', lw = 0.5)
        ax.tick_params(labelsize = 9)

    #make a custom legend
    import matplotlib.patches as mpatches
    handles = [mpatches.Patch(color = colors[2], label = 'PTMs Unchanged'), mpatches.Patch(color = colors[1], label = 'Inclusion Change'), mpatches.Patch(color = colors[0], label = 'Altered Flank')]
    ax.legend(handles = handles, ncol = 1, loc = 'upper center', bbox_to_anchor = leg_loc, fontsize = 9)


    ax.set_xlabel('EnrichR Combined Score', fontsize = 9)

def get_overlap_between_terms(ptm_results, term1, term2):
    """
    Given EnrichR two terms, return the overlap in genes associated with the terms
    
    Parameters
    ----------
    ptm_results: pd.selfFrame
        selfFrame containing PTM-specific results from EnrichR analysis
    term1: str
        first term to compare
    term2: str
        second term to compare
    
    Returns
    -------
    set
        set containing genes that are associated with both terms
    """
    #compare two terms
    relevant_genes1 = ptm_results.loc[ptm_results['Term'] == term1, 'Genes_ptm'].str.split(';').values[0]
    relevant_genes2 = ptm_results.loc[ptm_results['Term'] == term2, 'Genes_ptm'].str.split(';').values[0]

    intersection = set(relevant_genes1).intersection(relevant_genes2)
    return intersection

def extract_ptms_related_to_term(ptm_results, self, term = None):
    """
    given a Gene-level term of interest, extract the genes associated with the term and the subsequent ptms associated with those genes

    Parameters
    ----------
    ptm_results: pd.selfFrame
        selfFrame containing PTM-specific results from EnrichR analysis
    self: Figure4_new
        Figure4_new object containing PTM self
    term: str
        term of interest to extract PTMs from, must match column in ptm_results. If none will return all significant ptms
    """
    relevant_ptm_annotations = self.annotated_ptms[self.annotated_ptms['Source of PTM'].isin(self.sig_ptms['Source of PTM'])].copy()
    relevant_ptm_psi = self.sig_ptms.copy()
    relevant_flanks = self.annotated_ptms[self.annotated_ptms['Source of PTM'].isin(relevant_flanks['Source of PTM'])].copy()

    if term is not None:
        relevant_genes = ptm_results.loc[ptm_results['Term'] == term, 'Genes_ptm'].str.split(';').values[0]
        relevant_ptm_annotations = relevant_ptm_annotations[(relevant_ptm_annotations['Gene'].isin(relevant_genes))].copy()
        relevant_flanks = relevant_flanks[relevant_flanks['Gene'].isin(relevant_genes)].copy()
        relevant_ptm_psi = self.sig_ptms[self.sig_ptms['Gene'].isin(relevant_genes)]


    relevant_ptm_annotations = pd.concat([relevant_ptm_annotations, relevant_flanks])
    relevant_ptm_annotations['PTM'] =  relevant_ptm_annotations.apply(lambda x: x['UniProtKB Accession'] + '_' + x['Residue']+ str(int(x['PTM Position in Canonical Isoform'])) if x['PTM Position in Canonical Isoform'] == x['PTM Position in Canonical Isoform'] else x['Source of PTM'].split(';')[0], axis = 1)
    return relevant_ptm_annotations, relevant_ptm_psi


def plot_ptms_with_term(relevant_ptm_annotations, annotation_name, high_ptm_list, low_ptm_list, flank_ptm_list, top_terms = 10, colors = None, collapse_on_similar = False, ax = None):
    """
    Plot barplot indicating the number of ptms associated with ptm-specific terms
    
    Parameters
    ----------
    relevant_ptm_annotations: pd.selfFrame
        selfFrame containing PTM annotations, use extract_ptms_related_to_term to generate
    annotation_name: str
        name of column in relevant_ptm_annotations to plot
    high_ptm_list: list
        list of PTMs associated with ESRP1-high patients
    low_ptm_list: list
        list of PTMs associated with ESRP1-low patients
    flank_ptm_list: list
        list of PTMs associated with altered flanking sequences
    top_terms: int
        number of top terms to plot
    collapse_on_similar: bool
        whether to collapse similar terms into a single category
    ax: matplotlib.Axes
        axis to plot on, if None, will create new figure
    
    Returns
    -------
    ax: matplotlib.Axes
        axis containing plot
    """
    pivot_table = stat_utils.constructPivotTable(relevant_ptm_annotations, annotation_name, collapse_on_similar = collapse_on_similar)
    pivot_table.columns = [col.replace('_',' ') for col in pivot_table.columns]
    all_ptms = pivot_table.count().sort_values(ascending = True).iloc[-1*top_terms:]

    #split into high and low ptms
    low_ptms_self = pivot_table[pivot_table.index.isin(low_ptm_list)].count()
    for idx in all_ptms.index:
        if idx not in low_ptms_self.index:
            low_ptms_self[idx] = 0
    low_ptms_self = low_ptms_self.loc[all_ptms.index]
    high_ptms_self = pivot_table[pivot_table.index.isin(high_ptm_list)].count()
    for idx in all_ptms.index:
        if idx not in high_ptms_self.index:
            high_ptms_self[idx] = 0
    high_ptms_self = high_ptms_self.loc[all_ptms.index]

    flank_ptms_self = pivot_table[pivot_table.index.isin(flank_ptm_list)].count()
    for idx in all_ptms.index:
        if idx not in flank_ptms_self.index:
            flank_ptms_self[idx] = 0
    flank_ptms_self = flank_ptms_self.loc[all_ptms.index]

    if ax is None:
        fig, ax = plt.subplots(figsize = (1.5,1.5))

    if colors is None:
        colors = ['lightgrey', 'gray', 'white']
    ax.barh(low_ptms_self.index, low_ptms_self.values, height = 1, edgecolor = 'black', color = colors[0])
    ax.barh(high_ptms_self.index, high_ptms_self.values, left = low_ptms_self.values, height = 1, color = colors[1], edgecolor = 'black')
    ax.barh(flank_ptms_self.index, flank_ptms_self.values, left = low_ptms_self.values+high_ptms_self.values, height = 1, color = colors[2], edgecolor = 'black')
    #ax.set_xticks([0,50,100,150])
    ax.set_ylabel('', fontsize = 9)
    ax.set_xlabel('Number of PTMs', fontsize = 8)
    #rotate xtick labels
    ax.tick_params(labelsize = 7)
    return ax

def extract_ptms_with_term(relevant_ptm_annotations, term):
    """
    Given a annotation of interest, extract the PTMs associated with that term

    Parameters
    ----------
    relevant_ptm_annotations: pd.selfFrame
        selfFrame containing PTM annotations, use extract_ptms_related_to_term to generate
    term: str
        term of interest to extract PTMs from, must match column in relevant_ptm_annotations

    Returns
    -------
    pd.selfFrame
        selfFrame containing PTMs associated with term
    """
    return relevant_ptm_annotations.dropna(subset=[term])[['Gene', 'UniProtKB Accession', 'Residue', "PTM Position in Canonical Isoform", term]]


